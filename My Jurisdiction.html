<script>
    /***********************************************************************
     * My Jurisdiction Page - HSTD/OOJ Management Application
     * 
     * This application provides an interface for managing jurisdiction data,
     * contacts, and out-of-jurisdiction (OOJ) details using GraphQL for data
     * communication with the WordPress backend.
     * 
     * The page is organized with three main grids:
     * 1. Jurisdiction Grid - Displays and allows editing of jurisdiction details
     * 2. Contacts Grid - Shows users associated with the jurisdiction
     * 3. OOJ Grid - Manages out-of-jurisdiction information
     * 
     * All data operations are performed via GraphQL API calls to the backend.
     ***********************************************************************/

    /***********************************************************************
     * GRAPHQL QUERIES AND MUTATIONS
     * Centralized location for all GraphQL operations to avoid duplication
     ***********************************************************************/
    const GraphQLQueries = {
        // User and Jurisdiction Queries
        currentUserJurisdiction: `
            query CurrentUserJurisdiction {
                viewer {
                    stdContactDetails {
                        userJurisdiction {
                            nodes {
                                databaseId
                            }
                        }
                    }
                }
            }
        `,
        
        getUsersByJurisdiction: `
            query GetUsersByJurisdiction($jurisdictionId: Int!) {
                users(where: {jurisdictionDatabaseId: $jurisdictionId}) {
                    nodes {
                        databaseId
                        firstName
                        lastName
                        email
                        stdContactDetails {
                            userJurisdiction {
                                nodes {
                                    databaseId
                                }
                            }
                            hivRole {
                                nodes {
                                    databaseId
                                    name
                                }
                            }
                            stiRole {
                                nodes {
                                    databaseId
                                    name
                                }
                            }
                            userPhone
                            userFax
                            notesStiHiv
                        }
                    }
                }
            }
        `,
        
        getJurisdictionUsers: `
            query GetJurisdictionUsers($jurisdictionId: Int!) {
                users(where: { jurisdictionDatabaseId: $jurisdictionId }) {
                    nodes {
                        databaseId
                        firstName
                        lastName
                    }
                }
            }
        `,
        
        // Role Queries
        getRoleLists: `
            query GetRoleLists {
                hIVRoles {
                    nodes {
                        databaseId
                        name
                    }
                }
                sTIRoles {
                    nodes {
                        databaseId
                        name
                    }
                }
            }
        `,
        
        getHIVRoles: `
            query GetHIVRoles {
                hIVRoles {
                    nodes {
                        databaseId
                        name
                        slug
                    }
                }
            }
        `,
        
        getSTIRoles: `
            query GetSTIRoles {
                sTIRoles {
                    nodes {
                        databaseId
                        name
                        slug
                    }
                }
            }
        `,
        
        // Completely updated OOJ query with proper sub-selections
        getOOJData: `
            query GetOOJData($jurisdictionId: ID!) {
                jurisdiction(id: $jurisdictionId, idType: DATABASE_ID) {
                    databaseId
                    title
                    oojJurisdictionDetails {
                        oojDetails {
                            oojId
                            oojInfection {
                                nodes {
                                    databaseId
                                    name
                                }
                            }
                            oojActivity {
                                nodes {
                                    databaseId
                                    name
                                }
                            }
                            lastDateOfExposure
                            dispositionsReturned
                            acceptAndInvestigate
                            methodOfTransmitting {
                                nodes {
                                    databaseId
                                    name
                                }
                            }
                            acceptableForPii {
                                nodes {
                                    databaseId
                                    name
                                }
                            }
                            notes
                            pointOfContacts {
                                nodes {
                                    databaseId
                                    firstName
                                    lastName
                                }
                            }
                        }
                    }
                }
            }
        `,
        getUserJurisdiction: `
            query GetUserJurisdiction {
                viewer {
                    stdContactDetails {
                        userJurisdiction {
                            nodes {
                                ... on Jurisdiction {
                                    databaseId
                                    title
                                }
                            }
                        }
                    }
                }
            }
        `,
        
        getOOJInfections: `
            query GetOOJInfections {
                oOJInfections {
                    nodes {
                        databaseId
                        name
                    }
                }
            }
        `,
        
        getOOJActivities: `
            query GetOOJActivities {
                oOJActivities {
                    nodes {
                        databaseId
                        name
                    }
                }
            }
        `,
        
        getMethodsOfTransmitting: `
            query GetMethodsOfTransmitting {
                methodsOfTransmitting {
                    nodes {
                        databaseId
                        name
                    }
                }
            }
        `,
        
        getAcceptableForPii: `
            query GetAcceptableForPII {
                acceptableForPiis {
                    nodes {
                        databaseId
                        name
                    }
                }
            }
        `,
    };

    const GraphQLMutations = {
        // User Mutations
        updateUser: `
            mutation UpdateUser($input: UpdateUserInput!) {
                updateUser(input: $input) {
                    user {
                        databaseId
                        firstName
                        lastName
                    }
                }
            }
        `,
        
        createUser: `
            mutation CreateUser($input: CreateUserInput!) {
                createUser(input: $input) {
                    user {
                        databaseId
                        firstName
                        lastName
                    }
                }
            }
        `,
        
        // OOJ Mutations
        updateOOJData: `
            mutation UpdateOOJDetails($input: UpdateOOJDetailsInput!) {
                updateOOJDetails(input: $input) {
                    clientMutationId
                }
            }
        `,
        
        createOOJData: `
            mutation CreateOOJData($input: UpdateOOJDetailsInput!) {
                updateOOJDetails(input: $input) {
                    clientMutationId
                }
            }
        `,
        
        deleteOOJData: `
            mutation DeleteOOJData($input: DeleteOojDataInput!) {
                deleteOojData(input: $input) {
                    deletedId
                }
            }
        `
    };

    /***********************************************************************
     * UTILITY FUNCTIONS
     * Common helper functions used throughout the application
     ***********************************************************************/
    
    /**
     * Execute an async operation with standard error handling
     * @param {Function} operation Function to execute
     * @param {string} errorMessage User-friendly error message
     * @param {Function} onSuccess Optional success callback
     * @param {Function} onError Optional error callback for custom error handling
     * @returns {Promise<any>} The result of the operation, or null on error
     */
    async function withErrorHandling(operation, errorMessage, onSuccess, onError) {
        try {
            const result = await operation();
            if (onSuccess) onSuccess(result);
            return result;
        } catch (error) {
            console.error(errorMessage, error);
            showNotification(errorMessage);
            if (onError) onError(error);
            return null;
        }
    }

    /**
     * Helper function to show notifications
     * @param {string} message The message to display
     * @param {string} type The notification type (error, success, info, warning)
     */
    function showNotification(message, type = 'error') {
        if (window.kendo && kendo.ui.Notification) {
            const notification = $("<div/>").appendTo("body").kendoNotification({
                position: {
                    pinned: true,
                    top: 30,
                    right: 30
                },
                autoHideAfter: 5000,
                stacking: "down",
                templates: [{
                    type: "error",
                    template: "<div class='notification-error'><span class='k-icon k-i-error'></span>#= message #</div>"
                }, {
                    type: "success",
                    template: "<div class='notification-success'><span class='k-icon k-i-success'></span>#= message #</div>"
                }, {
                    type: "warning",
                    template: "<div class='notification-warning'><span class='k-icon k-i-warning'></span>#= message #</div>"
                }]
            }).data("kendoNotification");

            notification.show({ message: message }, type);
        } else {
            console.error('Kendo UI Notification not available, message:', message);
            alert(message); // Fallback to basic alert if Kendo isn't loaded
        }
    }

    /**
     * Helper function for making GraphQL requests with retry capability
     * @param {string} query GraphQL query or mutation string
     * @param {Object} variables Variables to pass to the GraphQL operation
     * @param {number} retryCount Current retry attempt (for recursive retry)
     * @returns {Promise<Object>} The GraphQL response
     */
    async function makeGraphQLRequest(query, variables = {}, retryCount = 0) {
        try {
            const maxRetries = 3;
            
            // Safely log the query by checking if it's a string first
            const queryPreview = typeof query === 'string' ? 
                (query.length > 100 ? query.substring(0, 100) + '...' : query) : 
                'Invalid query format';
                
            console.log('Making GraphQL request:', {
                query: queryPreview,
                variables: JSON.stringify(variables, null, 2)
            });
            
            // Ensure query is defined before proceeding
            if (!query || typeof query !== 'string') {
                throw new Error('Invalid GraphQL query: Query must be a non-empty string');
            }
            
            const response = await fetch('https://hivstiooj.cste.org/graphql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query,
                    variables
                })
            });

            // Always try to get the response text
            const responseText = await response.text();
            console.log('GraphQL response text:', responseText);
            
            // Handle non-200 responses
            if (!response.ok) {
                console.error('GraphQL request failed with status:', response.status);
                console.error('Error details:', responseText);
                
                // For 500 errors, log more details to help debug
                if (response.status === 500) {
                    console.error('Server error processing GraphQL request. Query:', query);
                    console.error('Variables:', JSON.stringify(variables, null, 2));
                }
                
                // Attempt retry for server errors (500s)
                if (response.status >= 500 && retryCount < maxRetries) {
                    console.log(`Retrying request (${retryCount + 1}/${maxRetries})...`);
                    // Exponential backoff - wait longer between each retry
                    const backoffTime = Math.pow(2, retryCount) * 1000;
                    await new Promise(resolve => setTimeout(resolve, backoffTime));
                    return makeGraphQLRequest(query, variables, retryCount + 1);
                }
                
                throw new Error(`GraphQL request failed: ${response.status} ${response.statusText}`);
            }

            // Parse the JSON response
            let result;
            try {
                result = JSON.parse(responseText);
            } catch (e) {
                console.error('Error parsing GraphQL response:', e);
                throw new Error('Invalid JSON response from GraphQL server');
            }
            
            // Check for GraphQL errors in the response
            if (result.errors && result.errors.length) {
                console.error('GraphQL errors:', result.errors);
                throw new Error(`GraphQL errors: ${result.errors.map(e => e.message).join(', ')}`);
            }
            
            console.log('GraphQL request successful, data:', result);
            return result;
        } catch (error) {
            console.error('Error in GraphQL request:', error);
            
            // Attempt retry for network errors
            if (error.message.includes('Failed to fetch') && retryCount < 3) {
                console.log(`Network error, retrying (${retryCount + 1}/3)...`);
                const backoffTime = Math.pow(2, retryCount) * 1000;
                await new Promise(resolve => setTimeout(resolve, backoffTime));
                return makeGraphQLRequest(query, variables, retryCount + 1);
            }
            
            throw error;
        }
    }

    /**
     * Creates a GraphQL-powered data transport for Kendo DataSource
     * @param {Object} config Transport configuration
     * @param {string} config.readQuery GraphQL query for reading data
     * @param {Object} config.readVariables Variables for the read query
     * @param {Function} config.readTransform Function to transform read results
     * @param {string} config.updateMutation GraphQL mutation for updating
     * @param {Function} config.updateVariablesBuilder Function to build update variables
     * @param {string} config.createMutation GraphQL mutation for creating
     * @param {Function} config.createVariablesBuilder Function to build create variables
     * @param {string} config.deleteMutation GraphQL mutation for deleting
     * @param {Function} config.deleteVariablesBuilder Function to build delete variables
     * @returns {Object} Kendo DataSource transport object
     */
    function createGraphQLTransport(config) {
        return {
            read: async (options) => {
                try {
                    console.log('Transport read operation with:', config.readVariables);
                    
                    const result = await makeGraphQLRequest(
                        config.readQuery, 
                        typeof config.readVariables === 'function' 
                            ? config.readVariables(options) 
                            : config.readVariables
                    );
                    
                    // Transform the data if a transform function is provided
                    const transformedData = config.readTransform 
                        ? config.readTransform(result, options)
                        : result.data;
                    
                    console.log('Transformed read data:', transformedData);
                    options.success(transformedData);
                } catch (error) {
                    console.error('Read operation failed:', error);
                    options.error(error);
                    showNotification('Failed to load data: ' + error.message);
                }
            },
            
            update: async (options) => {
                if (!config.updateMutation || !config.updateVariablesBuilder) {
                    console.warn('Update operation not configured');
                    options.success(options.data);
                    return;
                }
                
                try {
                    console.log('Transport update operation with model:', options.data);
                    
                    const variables = config.updateVariablesBuilder(options.data);
                    console.log('Update variables:', variables);
                    
                    const result = await makeGraphQLRequest(config.updateMutation, variables);
                    console.log('Update operation result:', result);
                    
                    const updatedData = config.updateTransform 
                        ? config.updateTransform(result, options.data)
                        : options.data;
                    
                    options.success(updatedData);
                    showNotification('Item updated successfully', 'success');
                } catch (error) {
                    console.error('Update operation failed:', error);
                    options.error(error);
                    showNotification('Failed to update item: ' + error.message);
                }
            },
            
            create: async (options) => {
                if (!config.createMutation || !config.createVariablesBuilder) {
                    console.warn('Create operation not configured');
                    options.success(options.data);
                    return;
                }
                
                try {
                    console.log('Transport create operation with model:', options.data);
                    
                    // Check if required fields have values
                    console.log('Model field values:');
                    for (const field in options.data) {
                        console.log(`- ${field}: ${JSON.stringify(options.data[field])}`);
                    }
                    
                    const variables = config.createVariablesBuilder(options.data);
                    console.log('Create variables prepared:', variables);
                    
                    // Log the GraphQL mutation being used
                    console.log('Using create mutation:', config.createMutation);
                    
                    const result = await makeGraphQLRequest(config.createMutation, variables);
                    console.log('Create operation result:', result);
                    
                    // Check for error details in the response
                    if (result.errors) {
                        console.error('GraphQL errors in create operation:', result.errors);
                        let errorMessage = 'Failed to create item: ';
                        errorMessage += result.errors.map(err => err.message).join('; ');
                        showNotification(errorMessage);
                        throw new Error(errorMessage);
                    }
                    
                    const createdData = config.createTransform 
                        ? config.createTransform(result, options.data)
                        : options.data;
                    
                    console.log('Transformed created data:', createdData);
                    
                    options.success(createdData);
                    showNotification('Item created successfully', 'success');
                } catch (error) {
                    console.error('Create operation failed:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        model: options.data,
                        config: {
                            createMutation: config.createMutation ? 'Configured' : 'Missing',
                            createVariablesBuilder: config.createVariablesBuilder ? 'Configured' : 'Missing',
                            createTransform: config.createTransform ? 'Configured' : 'Missing'
                        }
                    });
                    options.error(error);
                    showNotification('Failed to create item: ' + error.message);
                }
            },
            
            destroy: async (options) => {
                if (!config.deleteMutation || !config.deleteVariablesBuilder) {
                    console.warn('Delete operation not configured');
                    options.success(options.data);
                    return;
                }
                
                try {
                    console.log('Transport delete operation with model:', options.data);
                    
                    const variables = config.deleteVariablesBuilder(options.data);
                    console.log('Delete variables:', variables);
                    
                    const result = await makeGraphQLRequest(config.deleteMutation, variables);
                    console.log('Delete operation result:', result);
                    
                    options.success(options.data);
                    showNotification('Item deleted successfully', 'success');
                } catch (error) {
                    console.error('Delete operation failed:', error);
                    options.error(error);
                    showNotification('Failed to delete item: ' + error.message);
                }
            }
        };
    }

    /**
     * Creates a standardized Kendo UI Grid with common configurations
     * @param {string|jQuery} element The element or selector for the grid
     * @param {Object} config Grid configuration
     * @param {Object} config.dataSource The Kendo DataSource for the grid
     * @param {Array} config.columns Array of column definitions
     * @param {Object} config.toolbar Toolbar configuration (array of items or boolean)
     * @param {string} config.editable Edit mode ('inline', 'popup', or false)
     * @param {boolean} config.pageable Whether to enable paging
     * @param {number} config.height Grid height in pixels
     * @param {Function} config.dataBound Event handler for the dataBound event
     * @param {Object} config.schema Model schema definition
     * @returns {Object} The initialized Kendo UI Grid
     */
    function createKendoGrid(element, config) {
        console.log('Creating Kendo grid with config:', config);
        
        // Default configuration
        const defaultConfig = {
            pageable: true,
            height: 550,
            editable: 'inline',
            toolbar: ['create', 'save', 'cancel'],
            save: function(e) {
                console.log('Save event triggered:', e);
                
                // Track the save type (create vs update)
                const isNewItem = e.model.isNew && e.model.isNew();
                console.log('Is new item being saved?', isNewItem);
                
                // Call the original save function
                const originalSave = config.save || function() {};
                originalSave.call(this, e);
                
                // Add a manual refresh after successful save
                if (e.model) {
                    setTimeout(() => {
                        try {
                            this.dataSource.read();
                            
                            // Log success message with operation type
                            console.log(`Grid ${isNewItem ? 'creation' : 'update'} operation completed successfully`);
                        } catch (err) {
                            console.error('Error refreshing grid after save:', err);
                        }
                    }, 500);
                }
            },
            dataBound: function(e) {
                console.log('Grid data bound event triggered');
            }
        };
        
        // Merge default config with provided config
        const mergedConfig = { ...defaultConfig, ...config };
        
        // Initialize the grid
        const grid = $(element).kendoGrid(mergedConfig).data('kendoGrid');
        
        console.log('Grid initialized:', grid);
        return grid;
    }

    /**
     * Initializes the grid's data source for users in a jurisdiction
     * @param {string} jurisdictionId The ID of the jurisdiction to load users for
     * @returns {Promise<kendo.data.DataSource>} The initialized data source
     */
    async function initializeJurisdictionDatasource(jurisdictionId) {
        console.log('Initializing jurisdiction data source for:', jurisdictionId);

        try {
            // Fetch initial data using GraphQL
            const result = await makeGraphQLRequest(GraphQLQueries.getUsersByJurisdiction, { jurisdictionId });
            const initialData = result.data.usersByJurisdiction || [];
            
            console.log('Initial user data loaded:', initialData);
            
            // Create a data source with the GraphQL transport
            const dataSource = new kendo.data.DataSource({
                data: initialData,
                schema: {
                    model: {
                        id: "userId",
                        fields: {
                            userId: { editable: false, nullable: false },
                            firstName: { validation: { required: true } },
                            lastName: { validation: { required: true } },
                            email: { type: "string", validation: { required: true } },
                            roles: { defaultValue: [] },
                            oojroles: { defaultValue: [] },
                            contacts: { defaultValue: [] }
                        }
                    }
                },
                transport: createGraphQLTransport({
                    readQuery: GraphQLQueries.getUsersByJurisdiction,
                    readVariables: { jurisdictionId },
                    readTransform: (result) => result.data.usersByJurisdiction || [],
                    
                    updateMutation: GraphQLQueries.updateUserRoles,
                    updateVariablesBuilder: (model) => ({
                        userId: model.userId,
                        jurisdictionId: jurisdictionId,
                        roles: model.roles || [],
                        oojroles: model.oojroles || [],
                        contacts: model.contacts || []
                    }),
                })
            });
            
            console.log('Jurisdiction data source configured');
            return dataSource;
        } catch (error) {
            console.error('Error initializing jurisdiction data source:', error);
            showNotification('Failed to load user data. Please try again later.');
            throw error;
        }
    }

    /**
     * Initialize the Kendo UI grid for the Jurisdiction Users
     * @param {string} jurisdictionId ID of the jurisdiction to load users for
     */
    async function initializeJurisdictionGrid(jurisdictionId) {
        console.log('Initializing jurisdiction grid for:', jurisdictionId);
        
        try {
            // Initialize the data source
            const dataSource = await initializeJurisdictionDatasource(jurisdictionId);
            
            // Fetch role data for editors - use the correct getRoleLists query
            console.log('Fetching role data for jurisdiction grid...');
            const roleResult = await makeGraphQLRequest(GraphQLQueries.getRoleLists);
            const hivRoles = roleResult.data.hIVRoles.nodes;
            const stiRoles = roleResult.data.sTIRoles.nodes;
            console.log('Role data loaded successfully');
            
            // Create the grid using our utility function
            createKendoGrid('#userGrid', {
                dataSource: dataSource,
                columns: [
                    { field: "firstName", title: "First Name", width: "150px" },
                    { field: "lastName", title: "Last Name", width: "150px" },
                    { field: "email", title: "Email", width: "200px" },
                    { 
                        field: "roles", 
                        title: "Roles", 
                        width: "200px",
                        editor: createMultiSelectEditor({
                            type: 'Roles',
                            dataSource: hivRoles,
                            textField: 'name',
                            valueField: 'databaseId'
                        })
                    },
                    { 
                        field: "oojroles", 
                        title: "Out of Jurisdiction Roles", 
                        width: "200px",
                        editor: createMultiSelectEditor({
                            type: 'OOJ Roles',
                            dataSource: stiRoles,
                            textField: 'name',
                            valueField: 'databaseId'
                        })
                    },
                    { 
                        field: "contacts", 
                        title: "Contacts", 
                        width: "200px",
                        editor: createMultiSelectEditor({
                            type: 'Contacts',
                            dataSource: async () => {
                                // Fetch users for the jurisdiction to use as contacts
                                const result = await makeGraphQLRequest(
                                    GraphQLQueries.getUsersByJurisdiction, 
                                    { jurisdictionId: parseInt(jurisdictionId) }
                                );
                                return result.data.users.nodes || [];
                            },
                            textField: 'lastName',
                            valueField: 'databaseId'
                        })
                    },
                    { command: ["edit"], title: "&nbsp;", width: "250px" }
                ],
                editable: "inline",
                dataBound: function() {
                    console.log("Grid data bound event fired");
                }
            });
            
            console.log('Jurisdiction grid initialized successfully');
        } catch (error) {
            console.error('Failed to initialize jurisdiction grid:', error);
            throw error;
        }
    }

    /**
     * Main application initialization
     */
    async function initializeApplication() {
        console.log('Initializing application...');
        
        try {
            // Get the user's jurisdiction from GraphQL
            const result = await withErrorHandling(
                () => makeGraphQLRequest(GraphQLQueries.getUserJurisdiction),
                'Failed to load your jurisdiction information'
            );
            
            if (!result) return;
            
            const jurisdictionNode = result.data?.viewer?.stdContactDetails?.userJurisdiction?.nodes?.[0];
            const jurisdictionId = jurisdictionNode?.databaseId;
            const jurisdictionName = jurisdictionNode?.title || 'Unknown Jurisdiction';
            
            console.log('User jurisdiction loaded:', { jurisdictionId, jurisdictionName });
            
            if (!jurisdictionId) {
                showNotification('Your account does not have an associated jurisdiction. Please contact support.', 'warning');
                return;
            }
            
            // Update the header with the jurisdiction name
            $('#jurisdictionName').text(jurisdictionName);
            
            // Initialize reference data before initializing grids
            await withErrorHandling(
                () => initializeReferenceData(jurisdictionId),
                'Failed to initialize some reference data'
            );
            
            // Initialize all grids
            console.log('Initializing all grids for jurisdiction ID:', jurisdictionId);
            
            // Initialize all grids in parallel for better performance
            await Promise.all([
                // Initialize the jurisdiction grid
                withErrorHandling(
                    () => initializeJurisdictionGrid(jurisdictionId),
                    'Failed to initialize jurisdiction grid'
                ),
                
                // Initialize the contacts grid
                withErrorHandling(async () => {
                const contactsDataSource = initializeContactsDataSource(jurisdictionId);
                await initializeContactsGrid(contactsDataSource);
                    console.log('Contacts grid initialized successfully');
                }, 'Failed to initialize contacts grid'),
                
                // Initialize the OOJ grid
                withErrorHandling(
                    () => initializeOOJGrid(jurisdictionId),
                    'Failed to initialize OOJ grid'
                )
            ]);
                
            console.log('All grids initialized successfully');
            
            // Show a success notification
            showNotification('Application initialized successfully', 'success');
        } catch (error) {
            console.error('Application initialization failed:', error);
            showNotification('Application initialization failed. Please try refreshing the page.');
        }
    }
    
    /**
     * Document ready handler
     */
    $(document).ready(function () {
        console.log('Document ready, initializing application...');
        
        // Initialize our application
        initializeApplication().catch(error => {
            console.error('Critical error during initialization:', error);
            showNotification('A critical error occurred. Please refresh the page and try again.');
        });
    });

    /***********************************************************************
     * CONTACTS GRID INITIALIZATION
     ***********************************************************************/
    async function initializeContactsGrid(dataSource) {
        try {
            // First fetch the role lists
            console.log('Fetching role lists for grid initialization...');
            const query = GraphQLQueries.getRoleLists;
    
            const roleListsResult = await makeGraphQLRequest(query);
            console.log('Role lists received:', roleListsResult);

            const hivRoles = roleListsResult.data.hIVRoles.nodes;
            const stiRoles = roleListsResult.data.sTIRoles.nodes;

            // Check if the element exists
            const gridElement = $('#our-contacts');
            if (!gridElement.length) {
                throw new Error('Contacts grid element not found in DOM');
            }

            // Initialize the grid with the role data
            gridElement.kendoGrid({
                dataSource: dataSource,
                pageable: true,
                height: 550,
                toolbar: [{ name: 'create', text: 'Add New User' }, 'save', 'cancel'],
                columns: [
                    { field: 'first_name', title: 'First Name', validation: { required: true } },
                    { field: 'last_name', title: 'Last Name', validation: { required: true } },
                    { field: 'email', title: 'Email', validation: { required: true, email: true } },
                    {
                        field: 'acf.hiv_role',
                        title: 'HIV Role',
                        editor: userHIVRoleEditor,
                        template: function(dataItem) {
                            if (!dataItem.acf?.hiv_role?.length) {
                                return 'No HIV Role assigned';
                            }
                            return dataItem.acf.hiv_role
                                .map(id => {
                                    const role = hivRoles.find(role => role.databaseId === id);
                                    return role ? role.name : 'Unknown Role';
                                })
                                .join(', ');
                        }
                    },
                    {
                        field: 'acf.sti_role',
                        title: 'STI Role',
                        editor: userSTIRoleEditor,
                        template: function(dataItem) {
                            if (!dataItem.acf?.sti_role?.length) {
                                return 'No STI Role assigned';
                            }
                            return dataItem.acf.sti_role
                                .map(id => {
                                    const role = stiRoles.find(role => role.databaseId === id);
                                    return role ? role.name : 'Unknown Role';
                                })
                                .join(', ');
                        }
                    },
                    { field: 'acf.user_phone', title: 'Phone' },
                    { field: 'acf.user_fax', title: 'Fax' },
                    { field: 'acf.notes_sti_hiv', title: 'Notes' },
                    { command: ['edit', 'destroy'], title: '&nbsp;', width: '200px' }
                ],
                editable: 'inline',
                save: function(e) {
    console.log('Save event triggered:', e);
    // Add a manual refresh after successful save
    if (e.model) {
        // If we have a model, the save operation was started but might be in progress
        // Wait for it to complete before refreshing
        setTimeout(() => {
            try {
                // Refresh the grid data after save
                this.dataSource.read();
            } catch (err) {
                console.error('Error refreshing grid after save:', err);
            }
        }, 500);
    }
},
                dataBound: function(e) {
                    console.log('Grid data bound event triggered');
                    console.log('Current data:', this.dataSource.data());
                }
            });

            console.log('Contacts grid initialized with role data');
        } catch (error) {
            console.error('Failed to initialize contacts grid:', error);
            showNotification('Failed to initialize contacts grid: ' + error.message);
        }
    }

    /***********************************************************************
     * CURRENT USER JURISDICTION FETCHING
     ***********************************************************************/
    // Get current user's jurisdiction using WPGraphQL
    async function getCurrentUserJurisdiction() {
        const query = GraphQLQueries.currentUserJurisdiction;

    try {
            console.log('Fetching current user jurisdiction...');
            const result = await makeGraphQLRequest(query);
            console.log('User data received:', result);

            const jurisdictionId = result?.data?.viewer?.stdContactDetails?.userJurisdiction?.nodes?.[0]?.databaseId;
            if (!jurisdictionId) {
                throw new Error('No jurisdiction ID found in user data');
            }
        
        return jurisdictionId;
    } catch (error) {
            console.error('Error fetching user jurisdiction:', error);
            throw error;
        }
    }

    /***********************************************************************
     * USERS BY JURISDICTION FETCHING
     ***********************************************************************/
    // Get all users from the same jurisdiction
    async function getUsersByJurisdiction(jurisdictionId) {
        const query = GraphQLQueries.getUsersByJurisdiction;

        try {
            console.log('Fetching users for jurisdiction:', jurisdictionId);
            const result = await makeGraphQLRequest(query, { jurisdictionId: parseInt(jurisdictionId) });
            console.log('Users data received:', result);

            return result?.data?.users?.nodes || [];
        } catch (error) {
            console.error('Error fetching users for jurisdiction:', error);
            throw error;
        }
    }

    /***********************************************************************
     * JURISDICTION DATASOURCE INITIALIZATION
     ***********************************************************************/
    function initializeJurisdictionDatasource(jurisdictionId) {
        console.log("Initializing grid with jurisdiction ID:", jurisdictionId);

        // Initialize the Kendo Grid
        $("#juris_grid").kendoGrid({
            toolbar: ["save", "cancel"],
            dataSource: new kendo.data.DataSource({
                transport: {
                    read: async (options) => {
                        const query = `
                            query GetJurisdiction($id: ID!) {
                                jurisdiction(id: $id, idType: DATABASE_ID) {
                                    jurisdictionDetails {
                                        addressJurisdiction
                                        agencyName
                                        faxJurisdiction
                                        fipsCode
                                        phoneJurisdiction
                                    }
                                    title
                                }
                            }
                        `;

                        try {
                            console.log('Reading jurisdiction data...', options);
                            const result = await makeGraphQLRequest(query, { id: jurisdictionId });
                            console.log('Read operation result:', result);

                            const jurisdiction = result.data.jurisdiction;
                            const transformedData = {
                                id: jurisdictionId,
                                title: jurisdiction.title,
                                fipsCode: jurisdiction.jurisdictionDetails?.fipsCode || null,
                                agencyName: jurisdiction.jurisdictionDetails?.agencyName || null,
                                addressJurisdiction: jurisdiction.jurisdictionDetails?.addressJurisdiction || null,
                                phoneJurisdiction: jurisdiction.jurisdictionDetails?.phoneJurisdiction || null,
                                faxJurisdiction: jurisdiction.jurisdictionDetails?.faxJurisdiction || null
                            };
                            
                            console.log('Transformed data:', transformedData);
                            options.success([transformedData]);
                        } catch (error) {
                            console.error('Read operation failed:', error);
                            options.error(error);
                        }
                    },
                    update: async (options) => {
                        console.log('Update operation started with options:', options);
                        
                        if (!options.data) {
                            console.error('No data provided for update');
                            options.error(new Error('No data provided for update'));
                            return;
                        }

                        const updateData = options.data;
                        console.log('Data to be updated:', updateData);

                        const mutation = `
                            mutation UpdateJurisdiction($input: UpdateJurisdictionInput!) {
                                updateJurisdiction(input: $input) {
                                    jurisdiction {
                                        databaseId
                                        title
                                        jurisdictionDetails {
                                            addressJurisdiction
                                            agencyName
                                            faxJurisdiction
                                            fipsCode
                                            phoneJurisdiction
                    }
                }
            }
        }
    `;

    try {
                            const variables = {
                                input: {
                                    id: updateData.id.toString(),
                                    clientMutationId: `update-jurisdiction-${Date.now()}`,
                                    title: updateData.title,
                                    agencyName: updateData.agencyName,
                                    addressJurisdiction: updateData.addressJurisdiction,
                                    phoneJurisdiction: updateData.phoneJurisdiction,
                                    fipsCode: updateData.fipsCode,
                                    faxJurisdiction: updateData.faxJurisdiction
                                }
                            };

                            const result = await makeGraphQLRequest(mutation, variables);
                            console.log('Update mutation result:', result);

                            if (!result.data?.updateJurisdiction?.jurisdiction) {
                                throw new Error('Update response is missing jurisdiction data');
                            }

                            const updatedJurisdiction = result.data.updateJurisdiction.jurisdiction;
                            const transformedData = {
                                id: updatedJurisdiction.databaseId,
                                title: updatedJurisdiction.title,
                                fipsCode: updatedJurisdiction.jurisdictionDetails?.fipsCode || null,
                                agencyName: updatedJurisdiction.jurisdictionDetails?.agencyName || null,
                                addressJurisdiction: updatedJurisdiction.jurisdictionDetails?.addressJurisdiction || null,
                                phoneJurisdiction: updatedJurisdiction.jurisdictionDetails?.phoneJurisdiction || null,
                                faxJurisdiction: updatedJurisdiction.jurisdictionDetails?.faxJurisdiction || null
                            };

                            console.log('Update successful, transformed response:', transformedData);
                            options.success(transformedData);
                            showNotification('Jurisdiction updated successfully', 'success');
                        } catch (error) {
                            console.error('Update operation failed:', error);
                            options.error(error);
                            showNotification('Failed to update jurisdiction: ' + error.message);
                        }
                    }
                },
                schema: {
                    model: {
                        id: "id",
                        fields: {
                            id: { editable: false, nullable: true },
                            title: { type: "string", editable: true, nullable: true },
                            agencyName: { type: "string", editable: true, nullable: true },
                            addressJurisdiction: { type: "string", editable: true, nullable: true },
                            phoneJurisdiction: { type: "string", editable: true, nullable: true },
                            fipsCode: { type: "string", editable: true, nullable: true },
                            faxJurisdiction: { type: "string", editable: true, nullable: true }
                        }
                    }
                },
                batch: false
            }),
            pageable: false,
            height: 350,
            columns: [
                { 
                    field: "title", 
                    title: "Jurisdiction Name", 
                    width: 150,
                    editor: function(container, options) {
                        $('<input required name="' + options.field + '"/>')
                            .appendTo(container)
                            .kendoTextBox();
                    }
                },
                { field: "fipsCode", title: "FIPS Code", width: 100 },
                { field: "agencyName", title: "Agency Name", width: 200 },
                { field: "addressJurisdiction", title: "Agency Address", width: 250 },
                { field: "phoneJurisdiction", title: "Agency Phone (Main)", width: 150 },
                { command: ["edit"], title: "&nbsp;", width: "100px" }
            ],
            editable: "inline",
            save: function(e) {
                console.log('Save event triggered:', e);
            },
            dataBound: function(e) {
                console.log("Grid data bound event triggered");
                console.log("Current data:", this.dataSource.data());
            }
        });
        console.log("Grid initialized and data source set.");
    }

    /***********************************************************************
     * NOTIFICATION DISPLAY
     ***********************************************************************/
    // Helper function to show notifications
    function showNotification(message, type = 'error') {
        if (window.kendo && kendo.ui.Notification) {
            const notification = new kendo.ui.Notification({
                position: {
                    top: 30,
                    right: 30
                }
            });

            // Fix the notification type handling
            if (type === 'success') {
                notification.success(message);
            } else {
                notification.error(message);
            }
        } else {
            // Fallback to console
            if (type === 'success') {
                console.log(message);
            } else {
                console.error(message);
            }
        }
    }

    /***********************************************************************
     * CONTACTS DATASOURCE INITIALIZATION
     ***********************************************************************/
    // Initialize contacts data source with GraphQL integration
    function initializeContactsDataSource(jurisdictionId) {
        console.log('Initializing contacts grid for jurisdiction:', jurisdictionId);

        return new kendo.data.DataSource({
            transport: {
                read: async (options) => {
                    const query = GraphQLQueries.getUsersByJurisdiction;

                    try {
                        console.log('Reading users data for jurisdiction:', jurisdictionId);
                        const result = await makeGraphQLRequest(query, { 
                            jurisdictionId: parseInt(jurisdictionId) 
                        });
                        console.log('Users read operation result:', result);

                        const transformedData = result.data.users.nodes.map(user => ({
                            id: user.databaseId,
                            first_name: user.firstName,
                            last_name: user.lastName,
                            email: user.email,
                            acf: {
                                hiv_role: user.stdContactDetails?.hivRole?.nodes?.map(role => role.databaseId) || [],
                                sti_role: user.stdContactDetails?.stiRole?.nodes?.map(role => role.databaseId) || [],
                                user_phone: user.stdContactDetails?.userPhone || '',
                                user_fax: user.stdContactDetails?.userFax || '',
                                notes_sti_hiv: user.stdContactDetails?.notesStiHiv || ''
                            }
                        }));

                        console.log('Transformed users data:', transformedData);
                        options.success(transformedData);
                    } catch (error) {
                        console.error('Read operation failed:', error);
                        // Send an empty array when we get a server error instead of failing entirely
                        // This allows the grid to initialize even with server issues
                        console.log('Using fallback empty data for contacts grid due to server error');
                        options.success([]);
                        
                        // Add a user-friendly message in the grid
                        setTimeout(() => {
                            const grid = $("#our-contacts").data("kendoGrid");
                            if (grid) {
                                if (grid.tbody.find('tr.k-no-data').length) {
                                    grid.tbody.find('tr.k-no-data td').html(
                                        '<div class="alert alert-warning">'+
                                        '<strong>Server Error:</strong> Unable to load contact data. '+
                                        'Please try refreshing the page or contact support if this persists.'+
                                        '</div>'
                                    );
                                }
                            }
                        }, 100);
                        
                        // Show notification to user
                        showNotification('Warning: Unable to load contact data due to a server issue');
                    }
                },
                update: async (options) => {
                    try {
                        console.log('Starting user update operation:', {
                            originalData: options.data,
                            model: options.model
                        });
                        
                        // Convert the user ID to a proper Global Relay ID format
                        const userId = btoa(`user:${options.data.id}`);
                        console.log('Generated Global Relay ID:', {
                            originalId: options.data.id,
                            encodedId: userId,
                            decodedCheck: atob(userId)
                        });
                        
                        // Prepare the input based on the schema
                        const input = {
                            userId: userId,
                            hivRole: options.data.acf.hiv_role.map(id => parseInt(id)) || [],
                            stiRole: options.data.acf.sti_role.map(id => parseInt(id)) || [],
                            userPhone: options.data.acf.user_phone || '',
                            userFax: options.data.acf.user_fax || '',
                            notesStiHiv: options.data.acf.notes_sti_hiv || '',
                            userJurisdiction: parseInt(jurisdictionId)
                        };

                        console.log('Prepared mutation input:', {
                            input: input,
                            hivRoleType: typeof input.hivRole,
                            stiRoleType: typeof input.stiRole,
                            hivRoleValues: input.hivRole,
                            stiRoleValues: input.stiRole
                        });

                        const mutation = 'mutation UpdateUserStdContact($input: UpdateUserStdContactInput!) {\n' +
                            '    updateUserStdContact(input: $input) {\n' +
                            '        clientMutationId\n' +  // Changed response fields
                            '    }\n' +
                            '}';

                        const result = await makeGraphQLRequest(mutation, { input });
                        console.log('Update mutation complete result:', {
                            data: result.data,
                            errors: result.errors,
                            extensions: result.extensions
                        });

                        // Since we know the data was saved successfully, we'll return the original data with updates
                        const transformedData = {
                            ...options.data,
                            acf: {
                                ...options.data.acf,
                                hiv_role: input.hivRole,
                                sti_role: input.stiRole,
                                user_phone: input.userPhone,
                                user_fax: input.userFax,
                                notes_sti_hiv: input.notesStiHiv
                            }
                        };

                        console.log('Using original data with updates:', transformedData);
                        options.success(transformedData);
                        
                        // Only show success notification if there were no errors
                        if (!result.errors) {
                            showNotification('User updated successfully', 'success');
                        }

                       
                    } catch (error) {
                        console.error('Update operation failed:', {
                            error: error,
                            message: error.message,
                            stack: error.stack,
                            originalData: options.data
                        });
                        options.error(error);
                        // Only show error notification for actual errors
                        if (error.message !== 'Internal server error') {
                            showNotification('Failed to update user: ' + error.message);
                        }
                    }
                },
                create: async (options) => {
                    try {
                        console.log('Starting user create operation:', {
                            data: options.data
                        });
                        
                        // Generate a random password for the new user
                        const tempPassword = generateTemporaryPassword();
                        
                        // Step 1: Create the basic user (separate user data from contact details)
                        const createUserInput = {
                            username: options.data.email.split('@')[0],
                            email: options.data.email,
                            firstName: options.data.first_name,
                            lastName: options.data.last_name,
                            password: tempPassword,
                            roles: ["subscriber"]
                        };

                        console.log('Step 1: Creating user with input:', createUserInput);

                        const createUserMutation = 'mutation CreateUser($input: CreateUserInput!) {\n' +
                            '    createUser(input: $input) {\n' +
                            '        user {\n' +
                            '            databaseId\n' +
                            '            id\n' +
                            '            email\n' +
                            '            firstName\n' +
                            '            lastName\n' +
                            '}';

                        const createResult = await makeGraphQLRequest(createUserMutation, { input: createUserInput });
                        console.log('Create user result:', createResult);

                        if (!createResult.data || !createResult.data.createUser || !createResult.data.createUser.user) {
                            throw new Error('Failed to create user: Invalid response from server');
                        }

                        // Step 2: Update the user's contact details
                        const newUser = createResult.data.createUser.user;
                        const userId = btoa(`user:${newUser.databaseId}`); // Create Relay ID
                        
                        const updateContactInput = {
                            userId: userId,
                            hivRole: options.data.acf.hiv_role || [],
                            stiRole: options.data.acf.sti_role || [],
                            userPhone: options.data.acf.user_phone || '',
                            userFax: options.data.acf.user_fax || '',
                            notesStiHiv: options.data.acf.notes_sti_hiv || '',
                            userJurisdiction: parseInt(jurisdictionId)
                        };

                        console.log('Step 2: Updating user contact details with input:', updateContactInput);

                        const updateContactMutation = 'mutation UpdateUserStdContact($input: UpdateUserStdContactInput!) {\n' +
                            '    updateUserStdContact(input: $input) {\n' +
                            '        clientMutationId\n' +
                            '    }\n' +
                            '}';

                        const updateResult = await makeGraphQLRequest(updateContactMutation, { input: updateContactInput });
                        console.log('Update contact details result:', updateResult);

                        // Return the complete user data
                        const transformedData = {
                            id: newUser.databaseId,
                            first_name: newUser.firstName,
                            last_name: newUser.lastName,
                            email: newUser.email,
                            acf: {
                                hiv_role: updateContactInput.hivRole,
                                sti_role: updateContactInput.stiRole,
                                user_phone: updateContactInput.userPhone,
                                user_fax: updateContactInput.userFax,
                                notes_sti_hiv: updateContactInput.notesStiHiv
                            }
                        };

                        console.log('New user created with contact details:', transformedData);
                        options.success(transformedData);
                        showNotification('User created successfully', 'success');
                    } catch (error) {
                        console.error('Create operation failed:', error);
                        options.error(error);
                        showNotification('Failed to create user: ' + error.message);
                    }
                },
                destroy: async (options) => {
                    const mutation = 'mutation DeleteUser($input: DeleteUserInput!) {\n' +
                        '    deleteUser(input: $input) {\n' +
                        '        deletedId\n' +
                        '    }\n' +
                        '}';

                    try {
                        console.log('Deleting user:', options.data);
                        const result = await makeGraphQLRequest(mutation, {
                            input: {
                                id: options.data.id
                            }
                        });

                        console.log('Delete result:', result);
                        options.success(options.data);
                        showNotification('User deleted successfully', 'success');
                    } catch (error) {
                        console.error('Delete failed:', error);
                        options.error(error);
                        showNotification('Failed to delete user: ' + error.message);
                    }
                }
            },
            schema: {
                model: {
                    id: 'id',
                    fields: {
                        id: { type: 'number', editable: false },
                        first_name: { type: 'string' },
                        last_name: { type: 'string' },
                        email: { type: 'string' },
                        acf: {
                            defaultValue: {
                                hiv_role: [],
                                sti_role: [],
                                user_phone: '',
                                user_fax: '',
                                notes_sti_hiv: ''
                            }
                        }
                    }
                }
            },
            batch: false
        });
    }

    /***********************************************************************
     * ROLE LISTS FETCHING
     ***********************************************************************/
    // Function to fetch role lists
    async function fetchRoleLists() {
        const query = GraphQLQueries.getRoleLists;

        try {
            console.log('Fetching role lists...');
            const result = await makeGraphQLRequest(query);
            console.log('Role lists received:', result);

            return {
                hivRoles: result.data.hIVRoles.nodes.map(role => ({
                    id: role.databaseId,
                    name: role.name
                })),
                stiRoles: result.data.sTIRoles.nodes.map(role => ({
                    id: role.databaseId,
                    name: role.name
                }))
            };
        } catch (error) {
            console.error('Error fetching role lists:', error);
            showNotification('Failed to fetch role lists');
            return { hivRoles: [], stiRoles: [] };
        }
    }

    /***********************************************************************
     * ROLE EDITOR FUNCTIONS
     ***********************************************************************/
    // Consolidate role editor functions into a single function
    function createRoleEditor(roleType) {
        return function(container, options) {
            console.log('Initializing ' + roleType + ' role editor');
            
            const queryType = roleType === 'HIV' ? 'hIVRoles' : 'sTIRoles';
            const query = 'query Get' + roleType + 'Roles {\n' +
                '    ' + queryType + ' {\n' +
                '        nodes {\n' +
                '            databaseId\n' +
                '            name\n' +
                '            slug\n' +
                '        }\n' +
                '    }\n' +
                '}';

            const roleDataSource = new kendo.data.DataSource({
                transport: {
                    read: async (dataSourceOptions) => {
                        try {
                            console.log('Fetching ' + roleType + ' roles...');
                            const result = await makeGraphQLRequest(query);
                            console.log(roleType + ' roles received:', result);

                            const roles = result.data[queryType].nodes.map(role => ({
                                id: role.databaseId,
                                name: role.name
                            }));

                            dataSourceOptions.success(roles);
                        } catch (error) {
                            console.error('Error fetching ' + roleType + ' roles:', error);
                            dataSourceOptions.error(error);
                            showNotification('Failed to fetch ' + roleType + ' roles');
                        }
                    }
                }
            });

            const fieldName = 'acf.' + roleType.toLowerCase() + '_role';
            console.log('Accessing nested ' + roleType + ' role field:', options.model[fieldName]);
            
            $('<input data-bind="value:' + fieldName + '"/>')
                .appendTo(container)
                .kendoMultiSelect({
                    autoWidth: true,
                    dataTextField: 'name',
                    dataValueField: 'id',
                    dataSource: roleDataSource,
                    value: options.model[fieldName] || [],
                    valuePrimitive: true,
                    autoClose: false,
                    noDataTemplate: 'No roles available',
                    change: function(e) {
                        var selectedIds = this.value();
                        options.model.set(fieldName, selectedIds);
                        console.log('Updated ' + roleType + ' roles:', selectedIds);
        }
    });
};
    }

    // Replace the separate role editor functions with the consolidated version
    const userHIVRoleEditor = createRoleEditor('HIV');
    const userSTIRoleEditor = createRoleEditor('STI');

    /***********************************************************************
     * OOJ EDITOR FUNCTIONS
     ***********************************************************************/
    /**
     * Editor for OOJ Infection dropdown
     * @param {Object} container The container element for the editor
     * @param {Object} options Editor options from the grid
     */
    function oojInfectionEditor(container, options) {
        console.log('Initializing OOJ Infection editor');
        
        const query = `query GetOOJInfections {
            oOJInfections {
                nodes {
                    databaseId
                    name
                }
            }
        }`;
        
        const infectionDataSource = new kendo.data.DataSource({
            transport: {
                read: async (dataSourceOptions) => {
                    try {
                        console.log('Fetching OOJ Infections...');
                        const result = await makeGraphQLRequest(query);
                        console.log('OOJ Infections received:', result);
                        
                        const infections = result.data.oOJInfections.nodes.map(infection => ({
                            id: infection.databaseId,
                            name: infection.name
                        }));
                        
                        dataSourceOptions.success(infections);
                    } catch (error) {
                        console.error('Error fetching OOJ Infections:', error);
                        dataSourceOptions.error(error);
                        showNotification('Failed to fetch OOJ Infections');
                    }
                }
            }
        });
        
        $('<input name="' + options.field + '"/>')
            .appendTo(container)
            .kendoMultiSelect({
                autoWidth: true,
                dataTextField: 'name',
                dataValueField: 'id',
                dataSource: infectionDataSource,
                value: options.model[options.field] || [],
                valuePrimitive: true,
                autoClose: false
            });
    }

    /**
     * Editor for OOJ Activity dropdown
     * @param {Object} container The container element for the editor
     * @param {Object} options Editor options from the grid
     */
    function oojActivityEditor(container, options) {
        console.log('Initializing OOJ Activity editor');
        
        const query = `query GetOOJActivities {
            oOJActivities {
                nodes {
                    databaseId
                    name
                }
            }
        }`;
        
        const activityDataSource = new kendo.data.DataSource({
            transport: {
                read: async (dataSourceOptions) => {
                    try {
                        console.log('Fetching OOJ Activities...');
                        const result = await makeGraphQLRequest(query);
                        console.log('OOJ Activities received:', result);
                        
                        const activities = result.data.oOJActivities.nodes.map(activity => ({
                            id: activity.databaseId,
                            name: activity.name
                        }));
                        
                        dataSourceOptions.success(activities);
                    } catch (error) {
                        console.error('Error fetching OOJ Activities:', error);
                        dataSourceOptions.error(error);
                        showNotification('Failed to fetch OOJ Activities');
                    }
                }
            }
        });
        
        $('<input name="' + options.field + '"/>')
            .appendTo(container)
            .kendoMultiSelect({
                autoWidth: true,
                dataTextField: 'name',
                dataValueField: 'id',
                dataSource: activityDataSource,
                value: options.model[options.field] || [],
                valuePrimitive: true,
                autoClose: false
            });
    }

    /**
     * Editor for Method of Transmitting dropdown
     * @param {Object} container The container element for the editor
     * @param {Object} options Editor options from the grid
     */
    function methodOfTransmittingEditor(container, options) {
        console.log('Initializing Method of Transmitting editor');
        
        const query = `query GetMethodsOfTransmitting {
            methodsOfTransmitting {
                nodes {
                    databaseId
                    name
                }
            }
        }`;
        
        const methodDataSource = new kendo.data.DataSource({
            transport: {
                read: async (dataSourceOptions) => {
                    try {
                        console.log('Fetching Methods of Transmitting...');
                        const result = await makeGraphQLRequest(query);
                        console.log('Methods of Transmitting received:', result);
                        
                        const methods = result.data.methodsOfTransmitting.nodes.map(method => ({
                            id: method.databaseId,
                            name: method.name
                        }));
                        
                        dataSourceOptions.success(methods);
                    } catch (error) {
                        console.error('Error fetching Methods of Transmitting:', error);
                        dataSourceOptions.error(error);
                        showNotification('Failed to fetch Methods of Transmitting');
                    }
                }
            }
        });
        
        $('<input name="' + options.field + '"/>')
            .appendTo(container)
            .kendoMultiSelect({
                autoWidth: true,
                dataTextField: 'name',
                dataValueField: 'id',
                dataSource: methodDataSource,
                value: options.model[options.field] || [],
                valuePrimitive: true,
                autoClose: false
            });
    }

    /**
     * Editor for Acceptable for PII dropdown
     * @param {Object} container The container element for the editor
     * @param {Object} options Editor options from the grid
     */
    function acceptableForPiiEditor(container, options) {
        console.log('Initializing Acceptable for PII editor');
        
        const query = `query GetAcceptableForPII {
            acceptableForPiis {
                nodes {
                    databaseId
                    name
                }
            }
        }`;
        
        const piiDataSource = new kendo.data.DataSource({
            transport: {
                read: async (dataSourceOptions) => {
                    try {
                        console.log('Fetching Acceptable for PII options...');
                        const result = await makeGraphQLRequest(query);
                        console.log('Acceptable for PII options received:', result);
                        
                        const piiOptions = result.data.acceptableForPiis.nodes.map(option => ({
                            id: option.databaseId,
                            name: option.name
                        }));
                        
                        dataSourceOptions.success(piiOptions);
                    } catch (error) {
                        console.error('Error fetching Acceptable for PII options:', error);
                        dataSourceOptions.error(error);
                        showNotification('Failed to fetch Acceptable for PII options');
                    }
                }
            }
        });
        
        $('<input name="' + options.field + '"/>')
            .appendTo(container)
            .kendoMultiSelect({
                autoWidth: true,
                dataTextField: 'name',
                dataValueField: 'id',
                dataSource: piiDataSource,
                value: options.model[options.field] || [],
                valuePrimitive: true,
                autoClose: false
            });
    }

    /**
     * Editor for Point of Contacts dropdown
     * @param {Object} container The container element for the editor
     * @param {Object} options Editor options from the grid
     * @param {string} jurisdictionId The jurisdiction ID for the contacts
     */
    function pointOfContactsEditor(container, options) {
        console.log('Initializing Point of Contacts editor');
        
        // Get the jurisdictionId from the grid's container
        const jurisdictionId = $('#ooj_grid').data('jurisdictionId');
        
        if (!jurisdictionId) {
            console.error('No jurisdiction ID available for contacts editor');
            return;
        }
        
        const contactsDataSource = new kendo.data.DataSource({
            transport: {
                read: async (dataSourceOptions) => {
                    try {
                        console.log('Fetching contacts for jurisdiction:', jurisdictionId);
                        const result = await makeGraphQLRequest(
                            GraphQLQueries.getJurisdictionUsers, 
                            { jurisdictionId: parseInt(jurisdictionId) }
                        );
                        console.log('Contacts received:', result);
                        
                        const contacts = result.data.users.nodes.map(user => ({
                            id: user.databaseId,
                            name: `${user.firstName} ${user.lastName}`
                        }));
                        
                        dataSourceOptions.success(contacts);
                    } catch (error) {
                        console.error('Error fetching contacts:', error);
                        dataSourceOptions.error(error);
                        showNotification('Failed to fetch contacts');
                    }
                }
            }
        });
        
        $('<input name="' + options.field + '"/>')
            .appendTo(container)
            .kendoMultiSelect({
                autoWidth: true,
                dataTextField: 'name',
                dataValueField: 'id',
                dataSource: contactsDataSource,
                value: options.model[options.field] || [],
                valuePrimitive: true,
                autoClose: false
            });
    }

    /***********************************************************************
     * EDITOR HELPER FUNCTIONS
     ***********************************************************************/
    
    /**
     * Creates a dropdown editor for Kendo Grid
     * @param {Object} config Configuration object containing type and dataSource
     * @returns {Function} Editor function for the grid
     */
    function createDropDownEditor(config) {
        return function(container, options) {
            $('<input name="' + options.field + '"/>')
                .appendTo(container)
                .kendoDropDownList({
                    dataTextField: 'name',
                    dataValueField: 'id',
                    dataSource: config.dataSource,
                    value: options.model[options.field],
                    autoWidth: true
                });
        };
    }

    /**
     * Creates a multi-select editor for Kendo Grid
     * @param {Object} config Configuration object containing type and dataSource
     * @returns {Function} Editor function for the grid
     */
    function createMultiSelectEditor(config) {
        return function(container, options) {
            $('<input name="' + options.field + '"/>')
                .appendTo(container)
                .kendoMultiSelect({
                    dataTextField: 'name',
                    dataValueField: 'id',
                    dataSource: config.dataSource,
                    value: options.model[options.field] || [],
                    autoWidth: true,
                    valuePrimitive: true,
                    autoClose: false
                });
        };
    }

    /***********************************************************************
     * OOJ GRID INITIALIZATION
     ***********************************************************************/
    /**
     * Helper function to build contact names from contact IDs using the contacts data
     * @param {Array} contactIds Array of contact IDs
     * @param {Object} contactsData Data from the contacts query containing user information
     * @returns {Array} Array of contact names in format "FirstName LastName"
     */
    function buildContactNames(contactIds, contactsData) {
        if (!contactIds || !contactIds.length || !contactsData || !contactsData.data || !contactsData.data.users) {
            return [];
        }
        
        // Convert contactIds to numbers for consistent comparison
        const numericContactIds = contactIds.map(id => parseInt(id));
        
        // Build a map of contacts for faster lookup
        const contactMap = {};
        contactsData.data.users.nodes.forEach(user => {
            contactMap[user.databaseId] = `${user.firstName} ${user.lastName}`;
        });
        
        // Map each ID to a name if found
        return numericContactIds.map(id => {
            return contactMap[id] || `Contact ${id}`;
        });
    }

    /**
     * Initialize the OOJ Grid
     * @param {string} jurisdictionId - The ID of the jurisdiction to load data for
     * @returns {Promise<Object>} - The initialized Kendo Grid instance
     */
    async function initializeOOJGrid(jurisdictionId) {
        console.log('Initializing OOJ grid with jurisdiction ID:', jurisdictionId);
        
        try {
            // Store jurisdiction ID for editors to access
            $('#ooj_grid').data('jurisdictionId', jurisdictionId);
            
            // Create the data source
            const dataSource = new kendo.data.DataSource({
                transport: {
                    read: async (options) => {
                        try {
                            console.log('Reading OOJ data for jurisdiction:', jurisdictionId);
                            const result = await makeGraphQLRequest(GraphQLQueries.getOOJData, { 
                                jurisdictionId: jurisdictionId.toString() 
                            });
                            
                            const transformedData = result.data.jurisdiction.oojJurisdictionDetails.oojDetails.map(detail => ({
                                id: detail.oojId,
                                oojInfection: detail.oojInfection?.nodes?.[0]?.databaseId || null,
                                oojActivity: detail.oojActivity?.nodes?.map(n => n.databaseId) || [],
                                lastDateOfExposure: detail.lastDateOfExposure || '',
                                dispositionsReturned: detail.dispositionsReturned || '',
                                acceptAndInvestigate: detail.acceptAndInvestigate || '',
                                methodOfTransmitting: detail.methodOfTransmitting?.nodes?.map(n => n.databaseId) || [],
                                acceptableForPii: detail.acceptableForPii?.nodes?.map(n => n.databaseId) || [],
                                notes: detail.notes || '',
                                pointOfContacts: detail.pointOfContacts?.nodes?.map(n => n.databaseId) || []
                            }));
                            
                            options.success(transformedData);
                        } catch (error) {
                            console.error('Read operation failed:', error);
                            options.error(error);
                            showNotification('Failed to load OOJ data');
                        }
                    },
                    create: async (options) => {
                        try {
                            console.log('Creating new OOJ entry:', options.data);
                            
                            const mutation = GraphQLMutations.createOOJData;
                            const variables = {
                                input: {
                                    id: jurisdictionId.toString(),
                                    clientMutationId: `create-ooj-${Date.now()}`,
                                    oojDetails: [{
                                        oojId: Math.floor(Math.random() * 1000000),
                                        oojInfection: parseInt(options.data.oojInfection),
                                        oojActivity: options.data.oojActivity.map(id => parseInt(id)),
                                        lastDateOfExposure: options.data.lastDateOfExposure,
                                        dispositionsReturned: options.data.dispositionsReturned,
                                        acceptAndInvestigate: options.data.acceptAndInvestigate || '',
                                        methodOfTransmitting: options.data.methodOfTransmitting.map(id => parseInt(id)),
                                        acceptableForPii: options.data.acceptableForPii.map(id => parseInt(id)),
                                        notes: options.data.notes,
                                        pointOfContacts: options.data.pointOfContacts.map(id => parseInt(id))
                                    }]
                                }
                            };
                            
                            const result = await makeGraphQLRequest(mutation, variables);
                            console.log('Create operation result:', result);
                            
                            options.success(options.data);
                            showNotification('OOJ entry created successfully', 'success');
                        } catch (error) {
                            console.error('Create operation failed:', error);
                            options.error(error);
                            showNotification('Failed to create OOJ entry');
                        }
                    },
                    update: async (options) => {
                        try {
                            console.log('Updating OOJ entry:', options.data);
                            
                            const mutation = GraphQLMutations.updateOOJData;
                            const variables = {
                                input: {
                                    id: jurisdictionId.toString(),
                                    clientMutationId: `update-ooj-${Date.now()}`,
                                    oojDetails: [{
                                        oojId: parseInt(options.data.id),
                                        oojInfection: parseInt(options.data.oojInfection),
                                        oojActivity: options.data.oojActivity.map(id => parseInt(id)),
                                        lastDateOfExposure: options.data.lastDateOfExposure,
                                        dispositionsReturned: options.data.dispositionsReturned,
                                        acceptAndInvestigate: options.data.acceptAndInvestigate || '',
                                        methodOfTransmitting: options.data.methodOfTransmitting.map(id => parseInt(id)),
                                        acceptableForPii: options.data.acceptableForPii.map(id => parseInt(id)),
                                        notes: options.data.notes,
                                        pointOfContacts: options.data.pointOfContacts.map(id => parseInt(id))
                                    }]
                                }
                            };
                            
                            const result = await makeGraphQLRequest(mutation, variables);
                            console.log('Update operation result:', result);
                            
                            options.success(options.data);
                            showNotification('OOJ entry updated successfully', 'success');
                        } catch (error) {
                            console.error('Update operation failed:', error);
                            options.error(error);
                            showNotification('Failed to update OOJ entry');
                        }
                    },
                    destroy: async (options) => {
                        try {
                            console.log('Deleting OOJ entry:', options.data);
                            
                            const mutation = GraphQLMutations.deleteOOJData;
                            const variables = {
                                input: {
                                    jurisdictionId: jurisdictionId.toString(),
                                    oojId: options.data.id,
                                    clientMutationId: `delete-ooj-${Date.now()}`
                                }
                            };
                            
                            const result = await makeGraphQLRequest(mutation, variables);
                            console.log('Delete operation result:', result);
                            
                            options.success(options.data);
                            showNotification('OOJ entry deleted successfully', 'success');
                        } catch (error) {
                            console.error('Delete operation failed:', error);
                            options.error(error);
                            showNotification('Failed to delete OOJ entry');
                        }
                    }
                },
                schema: {
                    model: {
                        id: "id",
                        fields: {
                            id: { type: "number", editable: false },
                            oojId: { type: "number", editable: false },
                            oojInfection: { type: "number", validation: { required: true } },
                            oojActivity: { type: "object", defaultValue: [] },
                            lastDateOfExposure: { type: "string" },
                            dispositionsReturned: { type: "string" },
                            acceptAndInvestigate: { type: "string" },
                            methodOfTransmitting: { type: "object", defaultValue: [] },
                            acceptableForPii: { type: "object", defaultValue: [] },
                            notes: { type: "string", defaultValue: "" },
                            pointOfContacts: { type: "object", defaultValue: [] }
                        }
                    }
                }
            });
            
            // Initialize the grid
            $("#ooj_grid").kendoGrid({
                dataSource: dataSource,
                pageable: true,
                height: 550,
                toolbar: ["create", "save", "cancel", "excel"],
                columns: [
                    { 
                        field: "oojInfection", 
                        title: "Infection", 
                        width: "120px",
                        template: dataItem => {
                            // Make the template more robust against missing reference data
                            if (!oojInfectionList || !oojInfectionList.length) return dataItem.oojInfection || 'N/A';
                            const infection = oojInfectionList.find(inf => inf.id === dataItem.oojInfection);
                            return infection ? infection.name : 'N/A';
                        },
                        editor: createDropDownEditor({
                            type: 'OOJInfections',
                            dataSource: new kendo.data.DataSource({
                                data: oojInfectionList, // Use the pre-loaded list
                                transport: {
                                    read: async (options) => {
                                        if (oojInfectionList && oojInfectionList.length) {
                                            options.success(oojInfectionList);
                                            return;
                                        }
                                        
                                        try {
                                            const result = await makeGraphQLRequest(GraphQLQueries.getOOJInfections);
                                            const infections = result.data.oOJInfections.nodes.map(node => ({
                                                id: node.databaseId,
                                                name: node.name
                                            }));
                                            
                                            // Update the global list for future use
                                            oojInfectionList = infections;
                                            options.success(infections);
                                        } catch (error) {
                                            console.error('Error fetching OOJ Infections:', error);
                                            options.error(error);
                                        }
                                    }
                                }
                            })
                        })
                    },
                    { 
                        field: "oojActivity", 
                        title: "Activity", 
                        width: "150px",
                        template: dataItem => {
                            if (!dataItem.oojActivity?.length) return 'No activities';
                            // Make the template more robust against missing reference data
                            if (!oojActivityList || !oojActivityList.length) {
                                return dataItem.oojActivity.join(', ') || 'N/A';
                            }
                            return dataItem.oojActivity
                                .map(id => {
                                    const activity = oojActivityList.find(act => act.id === id);
                                    return activity ? activity.name : 'ID: ' + id;
                                })
                                .join(', ');
                        },
                        editor: createMultiSelectEditor({
                            type: 'OOJActivities',
                            dataSource: new kendo.data.DataSource({
                                data: oojActivityList, // Use the pre-loaded list
                                transport: {
                                    read: async (options) => {
                                        if (oojActivityList && oojActivityList.length) {
                                            options.success(oojActivityList);
                                            return;
                                        }

                                        try {
                                            const result = await makeGraphQLRequest(GraphQLQueries.getOOJActivities);
                                            const activities = result.data.oOJActivities.nodes.map(node => ({
                                                id: node.databaseId,
                                                name: node.name
                                            }));
                                            
                                            // Update the global list for future use
                                            oojActivityList = activities;
                                            options.success(activities);
                                        } catch (error) {
                                            console.error('Error fetching OOJ Activities:', error);
                                            options.error(error);
                                        }
                                    }
                                }
                            })
                        })
                    },
                    { 
                        field: "lastDateOfExposure", 
                        title: "Last Date of Exposure", 
                        width: "150px",
                        editor: function(container, options) {
                            $('<input name="lastDateOfExposure"/>')
                                .appendTo(container)
                                .kendoTextBox({
                                    value: options.model.lastDateOfExposure
                                });
                        }
                    },
                    { 
                        field: "dispositionsReturned", 
                        title: "Dispositions", 
                        width: "120px",
                        editor: function(container, options) {
                            $('<input name="dispositionsReturned"/>')
                                .appendTo(container)
                                .kendoTextBox({
                                    value: options.model.dispositionsReturned
                                });
                        }
                    },
                    { 
                        field: "acceptAndInvestigate", 
                        title: "Accept and Investigate", 
                        width: "150px",
                        editor: function(container, options) {
                            $('<input name="acceptAndInvestigate"/>')
                                .appendTo(container)
                                .kendoTextBox({
                                    value: options.model.acceptAndInvestigate
                                });
                        }
                    },
                    { 
                        field: "methodOfTransmitting", 
                        title: "Method of Transmitting", 
                        width: "150px",
                        template: dataItem => {
                            if (!dataItem.methodOfTransmitting?.length) return 'N/A';
                            // Make the template more robust against missing reference data
                            if (!methodsOfTransmissionList || !methodsOfTransmissionList.length) {
                                return dataItem.methodOfTransmitting.join(', ') || 'N/A';
                            }
                            return dataItem.methodOfTransmitting
                                .map(id => {
                                    const method = methodsOfTransmissionList.find(m => m.id === id);
                                    return method ? method.name : 'ID: ' + id;
                                })
                                .join(', ');
                        },
                        editor: createMultiSelectEditor({
                            type: 'MethodsOfTransmitting',
                            dataSource: new kendo.data.DataSource({
                                data: methodsOfTransmissionList, // Use the pre-loaded list
                                transport: {
                                    read: async (options) => {
                                        if (methodsOfTransmissionList && methodsOfTransmissionList.length) {
                                            options.success(methodsOfTransmissionList);
                                            return;
                                        }
                                        
                                        try {
                                            const result = await makeGraphQLRequest(GraphQLQueries.getMethodsOfTransmitting);
                                            const methods = result.data.methodsOfTransmitting.nodes.map(node => ({
                                                id: node.databaseId,
                                                name: node.name
                                            }));
                                            
                                            // Update the global list for future use
                                            methodsOfTransmissionList = methods;
                                            options.success(methods);
                                        } catch (error) {
                                            console.error('Error fetching Methods of Transmitting:', error);
                                            options.error(error);
                                        }
                                    }
                                }
                            })
                        })
                    },
                    { 
                        field: "acceptableForPii", 
                        title: "Acceptable for PII", 
                        width: "150px",
                        template: dataItem => {
                            if (!dataItem.acceptableForPii?.length) return 'N/A';
                            // Make the template more robust against missing reference data
                            if (!acceptableForPiiList || !acceptableForPiiList.length) {
                                return dataItem.acceptableForPii.join(', ') || 'N/A';
                            }
                            return dataItem.acceptableForPii
                                .map(id => {
                                    const pii = acceptableForPiiList.find(p => p.id === id);
                                    return pii ? pii.name : 'ID: ' + id;
                                })
                                .join(', ');
                        },
                        editor: createMultiSelectEditor({
                            type: 'AcceptableForPii',
                            dataSource: new kendo.data.DataSource({
                                data: acceptableForPiiList, // Use the pre-loaded list
                                transport: {
                                    read: async (options) => {
                                        if (acceptableForPiiList && acceptableForPiiList.length) {
                                            options.success(acceptableForPiiList);
                                            return;
                                        }
                                        
                                        try {
                                            const result = await makeGraphQLRequest(GraphQLQueries.getAcceptableForPii);
                                            const piiOptions = result.data.acceptableForPiis.nodes.map(node => ({
                                                id: node.databaseId,
                                                name: node.name
                                            }));
                                            
                                            // Update the global list for future use
                                            acceptableForPiiList = piiOptions;
                                            options.success(piiOptions);
                                        } catch (error) {
                                            console.error('Error fetching Acceptable for PII:', error);
                                            options.error(error);
                                        }
                                    }
                                }
                            })
                        })
                    },
                    { 
                        field: "notes", 
                        title: "Notes", 
                        width: "200px",
                        editor: function(container, options) {
                            $('<textarea class="k-textbox" name="notes" style="width: 100%; min-height: 60px;"/>')
                                .appendTo(container)
                                .attr("data-bind", "value:notes");
                        }
                    },
                    { 
                        field: "pointOfContacts", 
                        title: "Point of Contacts", 
                        width: "200px",
                        template: dataItem => {
                            if (!dataItem.pointOfContacts?.length) return 'No contacts';
                            // Make the template more robust against missing reference data
                            if (!jurisdictionUsersList || !jurisdictionUsersList.length) {
                                return dataItem.pointOfContacts.join(', ') || 'N/A';
                            }
                            return dataItem.pointOfContacts
                                .map(id => {
                                    const contact = jurisdictionUsersList.find(u => u.id === id);
                                    return contact ? `${contact.firstName} ${contact.lastName}` : 'ID: ' + id;
                                })
                                .join(', ');
                        },
                        editor: createMultiSelectEditor({
                            type: 'Contacts',
                            dataSource: new kendo.data.DataSource({
                                data: jurisdictionUsersList, // Use the pre-loaded list
                                transport: {
                                    read: async (options) => {
                                        if (jurisdictionUsersList && jurisdictionUsersList.length) {
                                            options.success(jurisdictionUsersList.map(user => ({
                                                id: user.id,
                                                name: `${user.firstName} ${user.lastName}`
                                            })));
                                            return;
                                        }
                                        
                                        try {
                                            const result = await makeGraphQLRequest(
                                                GraphQLQueries.getJurisdictionUsers,
                                                { jurisdictionId: parseInt(jurisdictionId) }
                                            );
                                            const contacts = result.data.users.nodes.map(user => ({
                                                id: user.databaseId,
                                                name: `${user.firstName} ${user.lastName}`
                                            }));
                                            
                                            // Update the global list for future use
                                            jurisdictionUsersList = result.data.users.nodes.map(user => ({
                                                id: user.databaseId,
                                                firstName: user.firstName,
                                                lastName: user.lastName
                                            }));
                                            
                                            options.success(contacts);
                                        } catch (error) {
                                            console.error('Error fetching contacts:', error);
                                            options.error(error);
                                        }
                                    }
                                }
                            })
                        })
                    },
                    { command: ["edit", "destroy"], title: "&nbsp;", width: "250px" }
                ],
                editable: "inline",
                save: function(e) {
                    console.log('OOJ Grid save event triggered:', e);
                    
                    if (e.model) {
                        // Force a delayed refresh to ensure server changes are displayed
                        setTimeout(() => {
                            console.log('Performing delayed grid refresh after save');
                            this.dataSource.read();
                        }, 2000);
                    }
                },
                dataBound: function() {
                    console.log('OOJ grid data bound');
                    
                    if (this.dataSource.data().length === 0) {
                        const noDataCell = $('#ooj_grid').find('tr.k-no-data td');
                        if (noDataCell.length) {
                            noDataCell.html(
                                '<div class="alert alert-info text-center p-4">'+
                                '<strong>No OOJ entries yet</strong><br>'+
                                'Click the "Add New" button above to create your first entry.</div>'
                            );
                        }
                    }
                }
            });
            
            console.log('OOJ grid initialized successfully');
            return $("#ooj_grid").data("kendoGrid");
        } catch (error) {
            console.error('Failed to initialize OOJ grid:', error);
            showNotification('Failed to initialize OOJ grid: ' + error.message);
            throw error;
        }
    }

    /**
     * Initialize the OOJ data source using GraphQL
     * @param {string} jurisdictionId - The ID of the jurisdiction to load data for
     * @returns {kendo.data.DataSource} - The initialized data source
     */
    function initializeOOJDataSource(jurisdictionId) {
        return new kendo.data.DataSource({
            transport: createGraphQLTransport({
                readQuery: GraphQLQueries.getOOJData,
                readVariables: { jurisdictionId: jurisdictionId.toString() },
                readTransform: (result) => {
                    const jurisdiction = result.data?.jurisdiction;
                    if (!jurisdiction) {
                        console.warn('No jurisdiction found in response');
                        return [];
                    }
                    
                    const oojDetails = jurisdiction.oojJurisdictionDetails?.oojDetails || [];
                    
                    return oojDetails.map(detail => {
                        const infectionNode = detail.oojInfection?.nodes[0] || {};
                        const activityNodes = detail.oojActivity?.nodes || [];
                        const methodNodes = detail.methodOfTransmitting?.nodes || [];
                        const piiNodes = detail.acceptableForPii?.nodes || [];
                        const contactNodes = detail.pointOfContacts?.nodes || [];
                        
                        return {
                            id: detail.oojId,
                            jurisdictionId: jurisdiction.databaseId,
                            title: jurisdiction.title,
                            oojId: detail.oojId,
                            oojInfection: infectionNode.databaseId,
                            oojInfectionName: infectionNode.name,
                            oojActivity: activityNodes.map(n => n.databaseId),
                            oojActivityNames: activityNodes.map(n => n.name),
                            lastDateOfExposure: detail.lastDateOfExposure,
                            dispositionsReturned: detail.dispositionsReturned,
                            methodOfTransmitting: methodNodes.map(n => n.databaseId),
                            methodOfTransmittingNames: methodNodes.map(n => n.name),
                            acceptableForPii: piiNodes.map(n => n.databaseId),
                            acceptableForPiiNames: piiNodes.map(n => n.name),
                            notes: detail.notes,
                            pointOfContacts: contactNodes.map(n => n.databaseId),
                            pointOfContactNames: contactNodes.map(n => `${n.firstName} ${n.lastName}`)
                        };
                    });
                },
                
                createMutation: GraphQLMutations.createOOJData,
                createVariablesBuilder: (data) => {
                    const oojId = data.oojId || Math.floor(Math.random() * 1000000).toString();
                    
                    return {
                        input: {
                            id: jurisdictionId.toString(),
                            clientMutationId: `grid-create-ooj-${Date.now()}`,
                            oojDetails: [{
                                oojId: parseInt(oojId),
                                oojInfection: parseInt(data.oojInfection) || 0,
                                oojActivity: Array.isArray(data.oojActivity) ? data.oojActivity.map(id => parseInt(id)) : [],
                                lastDateOfExposure: data.lastDateOfExposure || "",
                                dispositionsReturned: data.dispositionsReturned || "",
                                acceptAndInvestigate: data.acceptAndInvestigate || "",
                                methodOfTransmitting: Array.isArray(data.methodOfTransmitting) ? data.methodOfTransmitting.map(id => parseInt(id)) : [],
                                acceptableForPii: Array.isArray(data.acceptableForPii) ? data.acceptableForPii.map(id => parseInt(id)) : [],
                                notes: data.notes || "",
                                pointOfContacts: Array.isArray(data.pointOfContacts) ? data.pointOfContacts.map(id => parseInt(id)) : []
                            }]
                        }
                    };
                },
                
                updateMutation: GraphQLMutations.updateOOJData,
                updateVariablesBuilder: (data) => {
                    const oojId = parseInt(data.oojId);
                    if (!oojId) {
                        console.error('OOJ ID missing for update');
                        return null;
                    }
                    
                    const oojInfection = parseInt(data.oojInfection) || 0;
                    if (!oojInfection) {
                        console.error('Infection field missing for update');
                        return null;
                    }
                    
                    return {
                        input: {
                            id: parseInt(jurisdictionId),
                            clientMutationId: `grid-update-ooj-${Date.now()}`,
                            oojDetails: [{
                                oojId: oojId,
                                oojInfection: oojInfection,
                                oojActivity: Array.isArray(data.oojActivity) ? data.oojActivity.map(id => parseInt(id)) : [],
                                lastDateOfExposure: data.lastDateOfExposure || "",
                                dispositionsReturned: data.dispositionsReturned || "",
                                acceptAndInvestigate: data.acceptAndInvestigate || "",
                                methodOfTransmitting: Array.isArray(data.methodOfTransmitting) ? data.methodOfTransmitting.map(id => parseInt(id)) : [],
                                acceptableForPii: Array.isArray(data.acceptableForPii) ? data.acceptableForPii.map(id => parseInt(id)) : [],
                                notes: data.notes || "",
                                pointOfContacts: Array.isArray(data.pointOfContacts) ? data.pointOfContacts.map(id => parseInt(id)) : []
                            }]
                        }
                    };
                },
                
                deleteMutation: GraphQLMutations.deleteOOJData,
                deleteVariablesBuilder: (data) => ({
                    input: {
                        jurisdictionId: jurisdictionId.toString(),
                        oojId: data.oojId,
                        clientMutationId: `grid-delete-ooj-${Date.now()}`
                    }
                })
            }),
            
            schema: {
                model: {
                    id: "oojId",
                    fields: {
                        oojId: { type: "string", editable: false, defaultValue: null },
                        oojInfection: { type: "string", validation: { required: true } },
                        oojActivity: { type: "object", defaultValue: [] },
                        lastDateOfExposure: { type: "string" },
                        dispositionsReturned: { type: "string" },
                        acceptAndInvestigate: { type: "string" },
                        methodOfTransmitting: { type: "object", defaultValue: [] },
                        acceptableForPii: { type: "object", defaultValue: [] },
                        notes: { type: "string", defaultValue: "" },
                        pointOfContacts: { type: "object", defaultValue: [] }
                    }
                }
            },
            pageSize: 10
        });
    }

    /***********************************************************************
     * PASSWORD GENERATION FOR WORDPRESS USER CREATION
     ***********************************************************************/
    // Password generator for WordPress user creation
    function generateTemporaryPassword(length = 12) {
        const uppercaseChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const lowercaseChars = "abcdefghijklmnopqrstuvwxyz";
        const numberChars = "0123456789";
        const specialChars = "!@#$%^&*()_+~`|}{[]:;?><,./-=";

        const allChars = uppercaseChars + lowercaseChars + numberChars + specialChars;

        let password = "";

        // Ensure at least one character from each category
        password += uppercaseChars.charAt(Math.floor(Math.random() * uppercaseChars.length));
        password += lowercaseChars.charAt(Math.floor(Math.random() * lowercaseChars.length));
        password += numberChars.charAt(Math.floor(Math.random() * numberChars.length));
        password += specialChars.charAt(Math.floor(Math.random() * specialChars.length));

        // Fill the rest of the password length with random characters
        for (let i = password.length; i < length; i++) {
            password += allChars.charAt(Math.floor(Math.random() * allChars.length));
        }

        // Shuffle the password to mix up the guaranteed characters
        password = password.split("").sort(() => 0.5 - Math.random()).join("");

        return password;
    }

    // Add global variables to store the reference lists
    let oojInfectionList = [];
    let oojActivityList = [];
    let methodsOfTransmissionList = [];
    let acceptableForPiiList = [];
    let jurisdictionUsersList = [];

    /***********************************************************************
     * REFERENCE DATA INITIALIZATION
     ***********************************************************************/
    
    /**
     * Initialize the reference data lists needed for grid templates
     * @param {string} jurisdictionId - The jurisdiction ID for fetching users
     * @returns {Promise<void>}
     */
    async function initializeReferenceData(jurisdictionId) {
        console.log('Initializing reference data for grids...');
        
        try {
            // Fetch all reference data in parallel for better performance
            const [infectionResult, activityResult, methodResult, piiResult, usersResult] = await Promise.all([
                makeGraphQLRequest(GraphQLQueries.getOOJInfections),
                makeGraphQLRequest(GraphQLQueries.getOOJActivities),
                makeGraphQLRequest(GraphQLQueries.getMethodsOfTransmitting),
                makeGraphQLRequest(GraphQLQueries.getAcceptableForPii),
                makeGraphQLRequest(GraphQLQueries.getJurisdictionUsers, { jurisdictionId: parseInt(jurisdictionId) })
            ]);
            
            // Transform and store the data
            oojInfectionList = infectionResult.data.oOJInfections.nodes.map(node => ({
                id: node.databaseId,
                name: node.name
            }));
            
            oojActivityList = activityResult.data.oOJActivities.nodes.map(node => ({
                id: node.databaseId,
                name: node.name
            }));
            
            methodsOfTransmissionList = methodResult.data.methodsOfTransmitting.nodes.map(node => ({
                id: node.databaseId,
                name: node.name
            }));
            
            acceptableForPiiList = piiResult.data.acceptableForPiis.nodes.map(node => ({
                id: node.databaseId,
                name: node.name
            }));
            
            jurisdictionUsersList = usersResult.data.users.nodes.map(user => ({
                id: user.databaseId,
                firstName: user.firstName,
                lastName: user.lastName
            }));
            
            console.log('Reference data initialized successfully:', {
                infections: oojInfectionList.length,
                activities: oojActivityList.length,
                methods: methodsOfTransmissionList.length,
                piiOptions: acceptableForPiiList.length,
                users: jurisdictionUsersList.length
            });
        } catch (error) {
            console.error('Failed to initialize reference data:', error);
            showNotification('Failed to load some reference data. Grid displays may be limited.');
        }
    }
</script>