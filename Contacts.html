<script>
  // REST API endpoint
  const stdBaseUrl = "https://hivstiooj.cste.org/wp-json/wp/v2";

  // Global variables
  var selectedJurisdictionId = null; // ID of the jurisdiction selected in the dropdown
  var oojInfectionList = [];
  var oojActivityList = [];
  // var jurisdictionUsersList = []; // REMOVED - Contact Grid fetches its own data
  var stiRoleList = [];
  var hivRoleList = [];
  var jurisdictionDropdown;
  var jurisdictionGrid;
  var oojJurisdictionGrid;
  var contactGrid;
  var allJurisdictionList = []; // Holds all jurisdictions fetched initially
  var methodsOfTransmissionList = [];
  var acceptablePiisData = []; // <-- ADDED: Declare the global variable

  // Logger utility for consistent logging
  const logger = {
    info: function(message, data) {
      console.log(message, data || '');
    },
    error: function(message, error) {
      console.error(message, error || '');
    },
    warn: function(message, data) {
      console.warn(message, data || '');
    }
  };

  // --- Helper function to add Nonce to AJAX requests ---
  function addNonceToAjax(xhr) {
      if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
          xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
      } else {
          logger.error("WP Nonce (wpApiSettings.nonce) is missing!");
      }
  }
  // --- End Helper ---

  $(document).ready(function () {
    initializeApplication();
  });

  // Main initialization function - Uses REST API
  async function initializeApplication() {
    try {
      logger.info("Initializing application with REST API...");
      
      // Fetch all necessary taxonomy and jurisdiction data using REST API
      const [
        oojInfectionData,
        oojActivityData,
        hivRoleData,
        stiRoleData,
        methodsOfTransmissionData,
        fetchedAcceptablePiisData,
        allJurisdictionData
      ] = await Promise.all([
        $.ajax({ url: stdBaseUrl + '/acf-ooj-infection?_fields=id,name&per_page=100', method: 'GET', beforeSend: addNonceToAjax }).catch(() => []),
        $.ajax({ url: stdBaseUrl + '/acf-ooj-activity?_fields=id,name&per_page=100', method: 'GET', beforeSend: addNonceToAjax }).catch(() => []),
        $.ajax({ url: stdBaseUrl + '/hiv-role?_fields=id,name&per_page=100', method: 'GET', beforeSend: addNonceToAjax }).catch(() => []),
        $.ajax({ url: stdBaseUrl + '/sti-role?_fields=id,name&per_page=100', method: 'GET', beforeSend: addNonceToAjax }).catch(() => []),
        $.ajax({ url: stdBaseUrl + '/iccr_method-of-transmitting?_fields=id,name&per_page=100', method: 'GET', beforeSend: addNonceToAjax }).catch(() => []),
        $.ajax({ url: stdBaseUrl + '/acceptable-for-pii?_fields=id,name&per_page=100', method: 'GET', beforeSend: addNonceToAjax }).catch(() => []),
        $.ajax({ url: stdBaseUrl + '/std_jurisdiction?_fields=id,title,modified,acf&per_page=3000', method: 'GET', beforeSend: addNonceToAjax }).catch(() => []) // Fetch all jurisdictions
      ]);

      // Set the global variables - Map data to consistent {id, name} or expected structure
      oojInfectionList = (oojInfectionData || []).map(item => ({ id: item.id, name: item.name }));
      oojActivityList = (oojActivityData || []).map(item => ({ id: item.id, name: item.name }));
      hivRoleList = (hivRoleData || []).map(item => ({ id: item.id, name: item.name }));
      stiRoleList = (stiRoleData || []).map(item => ({ id: item.id, name: item.name }));
      methodsOfTransmissionList = (methodsOfTransmissionData || []).map(item => ({ id: item.id, name: item.name }));
      acceptablePiisData = (fetchedAcceptablePiisData || []).map(item => ({ id: item.id, name: item.name }));
      allJurisdictionList = (allJurisdictionData || []).map(jurisdiction => ({ // Map jurisdiction data
        id: jurisdiction.id,
        title: jurisdiction.title || { rendered: "Unnamed" }, // Ensure title object exists
        modified: jurisdiction.modified,
        acf: jurisdiction.acf || {} // Ensure acf object exists
      }));

      // Log mapped data for verification
      logger.info("Mapped OOJ Infections:", oojInfectionList);
      logger.info("Mapped OOJ Activities:", oojActivityList);
      logger.info("Mapped HIV Roles:", hivRoleList);
      logger.info("Mapped STI Roles:", stiRoleList);
      logger.info("Mapped Methods of Transmission:", methodsOfTransmissionList);
      logger.info("Mapped Acceptable PIIs:", acceptablePiisData);
      logger.info("Mapped All Jurisdictions:", allJurisdictionList);
      
      // Initialize the UI components
      initializeJurisdictionDropdown();
      initializeJurisdictionGrid();
      initializeOojGrid(); // OOJ Grid already uses REST DataSource
      initializeContactGrid(); // Contact Grid now uses REST DataSource
      
      logger.info("Application initialized successfully (REST API)");
    } catch (error) {
      logger.error("Error initializing application (REST API):", error);
      // Consider showing a user-friendly error message here
       alert("Failed to load initial application data. Please check the console and try refreshing the page.");
    }
  }

/**
 * Formats an array of taxonomy objects (like {id, name}) into a comma-separated string of names for Excel export.
 * @param {Array|object} taxonomyItems - Array or array-like object of taxonomy items.
 * @returns {string} - Comma-separated string of names, or an empty string if input is invalid/empty.
 */
 function formatExcelTaxonomy(taxonomyItems) {
  // console.log('>>> formatExcelTaxonomy - Received input:', JSON.stringify(taxonomyItems)); // Keep for checking input
  try {
      const items = taxonomyItems || []; // Ensure we have an array or default to empty
      return items
        .filter(item => item && typeof item.name === 'string')
        .map(item => item.name)
        .join(", ");
   } catch (err) {
       console.error("Error during formatExcelTaxonomy processing:", err, "Input was:", taxonomyItems);
       return ""; // Return empty string on error
   }
}

/**
 * Formats an array of contact objects (like {firstName, lastName}) into a comma-separated string of full names for Excel export.
 * @param {Array|object} contactItems - Array or array-like object of contact items.
 * @returns {string} - Comma-separated string of full names (FirstName LastName), or an empty string if input is invalid/empty.
 */
function formatExcelContacts(contactItems) {
  // console.log('>>> formatExcelContacts - Received input:', JSON.stringify(contactItems)); // Keep for checking input
  try {
      const items = contactItems || []; // Ensure we have an array or default to empty
      return items
        .filter(item => item && typeof item.firstName === 'string' && typeof item.lastName === 'string')
        .map(item => `${item.firstName} ${item.lastName}`.trim())
        .join(", ");
  } catch (err) {
      console.error("Error during formatExcelContacts processing:", err, "Input was:", contactItems);
      return ""; // Return empty string on error
  }
  }

  // Initialize the jurisdiction dropdown
  function initializeJurisdictionDropdown() {
    // 1. Map the fetched jurisdictions to the simple {id, title} format
    const mappedJurisdictions = allJurisdictionList
        .map(item => ({
            id: item.id,
            title: item.title?.rendered || "Unnamed Jurisdiction" // Use rendered title directly
        }))
        .sort((a, b) => a.title.localeCompare(b.title)); // Sort alphabetically by title

    // 2. Prepare the final data array with "ALL" at the top
    const dropdownData = [
        { id: "ALL", title: "ALL" } // Add the "ALL" option first
    ].concat(mappedJurisdictions); // Add the sorted jurisdictions

    logger.info("Data prepared for Jurisdiction Dropdown:", dropdownData);

    // 3. Initialize the DropDownList with the prepared data
    jurisdictionDropdown = $("#jurisdictionDropdown").kendoDropDownList({
      dataTextField: "title", // Now directly references the 'title' property in dropdownData
      dataValueField: "id",
      dataSource: dropdownData, // Use the pre-processed array
      // No schema.data needed anymore for this static list
      valueTemplate: '#:title#', // Template uses the 'title' property
      template: '#:title#', // Template uses the 'title' property
      optionLabel: "Select a Jurisdiction...",
      change: function(e) {
         selectedJurisdictionId = this.value(); // Get the selected ID (or "ALL")
         logger.info("Jurisdiction selected:", selectedJurisdictionId);

         // Update the Jurisdiction Info Grid
         updateJurisdictionGrid(selectedJurisdictionId);

         // Trigger reads for the other grids using their REST DataSources
         if (contactGrid && contactGrid.dataSource) {
             logger.info("Triggering Contact Grid DataSource read for selection:", selectedJurisdictionId);
             contactGrid.dataSource.read();
         }
         if (oojJurisdictionGrid && oojJurisdictionGrid.dataSource) {
             logger.info("Triggering OOJ Grid DataSource read for selection:", selectedJurisdictionId);
             oojJurisdictionGrid.dataSource.read();
         }
     }
    }).data("kendoDropDownList");

    logger.info("Jurisdiction Dropdown Initialized.");
  }

  // Initialize the jurisdiction grid (displays info for the SINGLE selected jurisdiction)
  function initializeJurisdictionGrid() {
    jurisdictionGrid = $("#jurisdictionGrid").kendoGrid({
      dataSource: {
        data: [], // Initially empty, populated by updateJurisdictionGrid
        schema: {
          model: {
            id: "id", // Add id field if needed for Kendo operations
            fields: {
              id: { editable: false, nullable: true },
              title: {type: "string"}, // Mapped from title.rendered
              fips_code: {type: "string"},
              agency_name: {type: "string"},
              address_jurisdiction: {type: "string"},
              phone_jurisdiction: {type: "string"},
              modified: {type: "date"},
            },
          },
        },
      },
      columns: [
        {field: "title", title: "Jurisdiction Name"},
        // {field: "fips_code", title: "FIPS Code"}, // <-- REMOVED
        {field: "agency_name", title: "Agency Name"},
        {field: "address_jurisdiction", title: "Agency Address"},
        {field: "phone_jurisdiction", title: "Agency Phone"},
        {
          field: "modified",
          title: "Last Updated",
          template: function (dataItem) {
            // Basic check for valid date string
            if (!dataItem.modified || dataItem.modified === "0000-00-00T00:00:00") {
                return "N/A";
            }
            try {
                return kendo.toString(kendo.parseDate(dataItem.modified), "MM/dd/yyyy");
            } catch (e) {
                logger.warn("Could not parse date:", dataItem.modified);
                return "Invalid Date";
            }
          },
        },
      ],
      sortable: false
    }).data("kendoGrid");
  }

  // Initialize the OOJ grid - Already uses REST API DataSource
 function initializeOojGrid() {
    // Helper functions for ID extraction (remains the same)
    function extractIds(items) {
        if (!Array.isArray(items) || items.length === 0) return [];
        return items.map(item => typeof item === 'object' ? (item.id) : parseInt(item, 10)).filter(id => !isNaN(id));
    }

    var oojDataSource = new kendo.data.DataSource({
        transport: {
            create: { /* ... REST create config ... */
                contentType: "application/json",
                url: stdBaseUrl + "/ooj-detail",
                type: "POST",
                xhrFields: { withCredentials: true },
                beforeSend: addNonceToAjax
            },
            read: {
               url: function() {
                   // ALWAYS fetch ALL OOJ Details since server-side filtering isn't working
                   const baseUrl = stdBaseUrl + "/ooj-detail";
                   const embedParams = "_embed&per_page=3000&acf_format=standard"; // Use max limit, request ACF
                   const allUrl = `${baseUrl}?${embedParams}`;
                   logger.info(`OOJ Grid: Reading ALL jurisdictions via URL (filtering done client-side): ${allUrl}`);
                   return allUrl;
               },
               type: "GET",
               dataType: "json",
               xhrFields: { withCredentials: true },
               beforeSend: addNonceToAjax
           },
         update: { /* ... REST update config ... */
                contentType: "application/json",
                url: function(options) { return stdBaseUrl + "/ooj-detail/" + options.id; },
                type: "POST", // Or PUT with X-HTTP-Method-Override if needed
                xhrFields: { withCredentials: true },
                beforeSend: function(xhr) {
                    addNonceToAjax(xhr);
                     // If server requires PUT via POST override:
                    // xhr.setRequestHeader('X-HTTP-Method-Override', 'PUT');
                }
            },
            destroy: { /* ... REST destroy config ... */
                 url: function(options) { return stdBaseUrl + "/ooj-detail/" + options.id + "?force=true"; },
                type: "DELETE",
                xhrFields: { withCredentials: true },
                 beforeSend: addNonceToAjax
            },
            parameterMap: function(options, operation) {
                if (operation === "update" || operation === "create") {
                    logger.info(`OOJ parameterMap (${operation}): Preparing data from options:`, options);

                    if ((operation === "create" || operation === "update") && (!selectedJurisdictionId || selectedJurisdictionId === "ALL")) {
                         logger.error("Cannot create/update OOJ Detail without a specific selected jurisdiction in the dropdown.");
                         // Prevent Kendo from proceeding by returning non-JSON or triggering an error
                         // This case *should* be prevented by UI logic, but good to double-check
                         return "{}"; // Minimal JSON
                    }

                    // Determine the target jurisdiction ID for the payload
                    // For CREATE, use the globally selected one.
                    // For UPDATE, the item might already be linked, but WP REST usually needs it in ACF anyway.
                    // It's generally safer to always send the currently selected jurisdiction for ACF relationship fields.
                    const targetJurisdictionId = parseInt(selectedJurisdictionId, 10);
                     if (isNaN(targetJurisdictionId)) {
                         logger.error(`OOJ parameterMap (${operation}): Cannot proceed, invalid selectedJurisdictionId: ${selectedJurisdictionId}`);
                         return "{}";
                     }


                    const payloadObject = {
                        title: options.title || "OOJ Detail",
                        status: "publish",
                        acf: {
                             // *** IMPORTANT: Use the CORRECT ACF field name for the relationship ***
                            jurisdiction_selection: targetJurisdictionId, // Ensure this matches your ACF field key
                            last_date_of_exposure: options.lastDateOfExposure || "",
                            // Point of Contacts are now single IDs from the dropdown/model
                            point_of_contacts: options.pointOfContacts ? [options.pointOfContacts] : [], // Send as array even if single for WP ACF
                            dispositions_returned: options.dispositionsReturned || "",
                            accept_and_investigate: options.acceptAndInvestigate || "",
                            notes: options.notes || "",
                            ooj_phone: options.oojPhone != null ? String(options.oojPhone) : "",
                            ooj_fax: options.oojFax != null ? String(options.oojFax) : "",
                            ooj_email: options.oojEmail || ""
                        },
                        // Taxonomies - Pass array of term IDs
                        // Ensure these slugs match the REST API base slugs for the taxonomies
                        'acf-ooj-infection': options.oojInfections ? [options.oojInfections] : [], // Single select -> array
                        'acf-ooj-activity': options.oojActivities || [], // Multi-select -> array
                        'iccr_method-of-transmitting': options.methodsOfTransmitting || [], // Multi-select -> array
                        'acceptable-for-pii': options.acceptableForPiis || [] // Multi-select -> array
                    };
                    const jsonString = JSON.stringify(payloadObject);
                    logger.info(`OOJ parameterMap (${operation}): Returning JSON string:`, jsonString);
                    return jsonString;
                }
                logger.info(`OOJ parameterMap (${operation}): Using default handling for options:`, options);
                return options;
            }
        },
        schema: {
            model: {
                id: "id",
                fields: {
                    id: { editable: false, nullable: true },
                    title: { type: "string", defaultValue: "OOJ Detail" },
                    jurisdictionName: { type: "string", editable: false }, // Populated in parse
                    // Taxonomy fields store arrays of IDs
                    oojInfections: { defaultValue: [], validation: { required: true, message:"Infection required"} },
                    oojActivities: { defaultValue: [], validation: { required: true, message:"Activity required"} },
                    methodsOfTransmitting: { defaultValue: [] },
                    acceptableForPiis: { defaultValue: [] },
                    // Point of contacts stores array of contact IDs
                    pointOfContacts: { defaultValue: [], validation: { required: true, message:"POC required"} }, // Changed to array
                    // Other fields
                    lastDateOfExposure: { type: "string" },
                    dispositionsReturned: { type: "string" },
                    acceptAndInvestigate: { type: "string" }, // This field seems unused based on comments
                    notes: { type: "string" },
                    oojPhone: { type: "string" },
                    oojFax: { type: "string" },
                    oojEmail: { type: "string" }
                }
            },
            parse: function(response) {
                logger.info('OOJ Grid Parse (REST): Starting. Received response:', response);
                let dataToProcess = [];
                if (Array.isArray(response)) {
                    dataToProcess = response;
                } else if (response && typeof response === 'object' && response.id) {
                    dataToProcess = [response];
                } else {
                    logger.warn('OOJ Grid Parse: Response is not an array or valid object:', response);
                    return [];
                }

                // <<< --- START: Client-Side Filtering --- >>>
                if (selectedJurisdictionId && selectedJurisdictionId !== "ALL") {
                    const numericSelectedId = parseInt(selectedJurisdictionId, 10);
                    if (!isNaN(numericSelectedId)) {
                        logger.info(`OOJ Grid Parse: Filtering client-side for Jurisdiction ID: ${numericSelectedId}`);
                        dataToProcess = dataToProcess.filter(item => {
                            const itemJurisdictionId = item?.acf?.jurisdiction_selection?.ID;
                            // Keep item only if its jurisdiction ID matches the selected one
                            return itemJurisdictionId === numericSelectedId;
                        });
                        logger.info(`OOJ Grid Parse: Filtered down to ${dataToProcess.length} items.`);
                    } else {
                         logger.warn(`OOJ Grid Parse: Cannot filter client-side due to invalid selectedJurisdictionId: ${selectedJurisdictionId}`);
                    }
                } else {
                    logger.info(`OOJ Grid Parse: No client-side filtering needed (ALL or no selection). Processing ${dataToProcess.length} items.`);
                }
                // <<< --- END: Client-Side Filtering --- >>>


                // Proceed with mapping the (potentially filtered) data
                try {
                    return dataToProcess.map((item) => {
                        // logger.info(`\nOOJ Grid Parse: Processing item ID: ${item.id}`);
                        if (!item || typeof item !== 'object') { logger.warn(`OOJ Grid Parse: Item is invalid.`, item); return null; }

                        const acfData = item.acf || {};
                        const embeddedData = item._embedded || {};
                        let jurisdictionName = "Unknown"; // Default

                         // --- Jurisdiction Name Lookup ---
                        let jurisdictionId = null;
                        // Check ACF field first
                        const jurSelection = acfData.jurisdiction_selection;
                        if (jurSelection && typeof jurSelection === 'object' && jurSelection.ID && typeof jurSelection.post_title === 'string') {
                            jurisdictionId = parseInt(jurSelection.ID, 10); // Make sure to parse ID here
                            jurisdictionName = jurSelection.post_title;
                            // logger.info(`OOJ Grid Parse: Item ${item.id} - Found jurisdiction in ACF object: "${jurisdictionName}" (ID: ${jurisdictionId})`);
                        } else if (jurSelection !== null && jurSelection !== undefined && jurSelection !== '') {
                            // Handle case where jurisdiction_selection might just be an ID (less likely with _embed)
                            const parsedId = parseInt(jurSelection, 10);
                            if (!isNaN(parsedId)) {
                                jurisdictionId = parsedId;
                                // logger.info(`OOJ Grid Parse: Item ${item.id} - Parsed jurisdiction ID from ACF: ${jurisdictionId}. Looking up name.`);
                                const jurisdiction = allJurisdictionList.find(j => j && parseInt(j.id, 10) === jurisdictionId);
                                if (jurisdiction && jurisdiction.title && typeof jurisdiction.title.rendered === 'string') {
                                    jurisdictionName = jurisdiction.title.rendered;
                                    // logger.info(`OOJ Grid Parse: Item ${item.id} - Found name in global list: "${jurisdictionName}"`);
                                } else {
                                     logger.warn(`OOJ Grid Parse: Item ${item.id} - ID ${jurisdictionId} from ACF not found in global list or title invalid.`);
                                }
                            } else {
                                logger.warn(`OOJ Grid Parse: Item ${item.id} - Could not parse jurisdiction ID from ACF value:`, jurSelection);
                            }
                        } else {
                             logger.warn(`OOJ Grid Parse: Item ${item.id} - Jurisdiction selection field missing or empty in ACF.`);
                        }
                        // --- End Jurisdiction Name Lookup ---

                        // Helper to extract IDs from embedded terms or ACF fields
                        const getTermIds = (taxonomySlug) => {
                            // Prefer embedded terms if available
                            const terms = embeddedData['wp:term']?.flat()?.filter(t => t.taxonomy === taxonomySlug);
                            if (terms && terms.length > 0) {
                                return terms.map(t => t.id);
                            }
                            // Fallback to ACF field (if it stores IDs directly)
                            const acfValue = acfData[taxonomySlug.replace(/-/g, '_')]; // Basic slug to ACF key guess
                            if (Array.isArray(acfValue)) return acfValue.map(id => parseInt(id, 10)).filter(id => !isNaN(id));
                            if (acfValue) { const singleId = parseInt(acfValue, 10); return !isNaN(singleId) ? [singleId] : []; }
                            // Fallback to top-level if ACF fails (less common for taxonomies)
                            const topLevelValue = item[taxonomySlug];
                            if (Array.isArray(topLevelValue)) return topLevelValue.map(id => parseInt(id, 10)).filter(id => !isNaN(id));
                            return [];
                        };
                         // Helper to extract User IDs from embedded users or ACF field
                        const getContactIds = () => {
                             // Use the embedded user if available
                            const embeddedUsers = embeddedData['acf:user']; // Check the key from your JSON
                            if (embeddedUsers && Array.isArray(embeddedUsers) && embeddedUsers.length > 0) {
                                 // Assuming the embedded user object has an 'id' property
                                return embeddedUsers.map(u => u.id);
                            }
                             // Fallback to ACF field (point_of_contact seems to hold the user object now)
                            const acfContact = acfData.point_of_contact;
                             // Check if it's an object with an ID
                            if (acfContact && typeof acfContact === 'object' && acfContact.ID) {
                                 return [parseInt(acfContact.ID, 10)].filter(id => !isNaN(id));
                            }
                            // Fallback if it was just an ID (less likely based on JSON)
                            if (acfContact) { const singleId = parseInt(acfContact, 10); return !isNaN(singleId) ? [singleId] : []; }
                            return [];
                        };


                        const mappedItem = {
                            id: item.id,
                            title: item.title?.rendered || "OOJ Detail",
                            jurisdictionName: jurisdictionName,
                            // Get arrays of IDs using helpers
                            oojInfections: getTermIds('acf-ooj-infection'),
                            oojActivities: getTermIds('acf-ooj-activity'),
                            methodsOfTransmitting: getTermIds('iccr_method-of-transmitting'),
                            acceptableForPiis: getTermIds('acceptable-for-pii'),
                            pointOfContacts: getContactIds(), // Get array of contact IDs
                            // Other ACF fields directly
                            lastDateOfExposure: acfData.last_date_of_exposure || "",
                            dispositionsReturned: acfData.dispositions_returned || "",
                            acceptAndInvestigate: acfData.accept_and_investigate || "", // Seems unused
                            notes: acfData.notes || "",
                            oojPhone: acfData.ooj_phone || "",
                            oojFax: acfData.ooj_fax || "",
                            oojEmail: acfData.ooj_email || ""
                        };
                        // logger.info(`OOJ Grid Parse: Item ${item.id} - Final mapped item:`, mappedItem);
                        return mappedItem;
                    }).filter(item => item !== null);
                } catch (error) {
                    logger.error("OOJ Grid Parse: Error during map operation:", error);
                    return [];
                }
            },
            error: function(e) {
                 logger.error("OOJ DataSource Error:", e);
                let message = "An error occurred.";
                 if (e.xhr && e.xhr.responseJSON && e.xhr.responseJSON.message) {
                     message = e.xhr.responseJSON.message;
                 } else if (e.errors) { message = Array.isArray(e.errors) ? e.errors.join(", ") : String(e.errors); }
                 alert("Data Error: " + message); // Simplified alert
                 var grid = $("#oojJurisdictionGrid").data("kendoGrid");
                 if (grid) { grid.cancelChanges(); }
            }
        }, // End schema
        change: function(e) {
            if (e.action === "itemchange" && e.items && e.items.length > 0) { e.items[0].dirty = true; }
        }
    }); // End DataSource

    // --- Generic Template/Editor Factories (assuming these exist from My Jurisdiction v2) ---
     function createTaxonomyTemplate(fieldName, isMultiSelect = true) {
         return function(dataItem) {
             const ids = dataItem[fieldName]; // Expecting array of IDs
             if (!ids || ids.length === 0) return '—';

             let lookupList;
             switch (fieldName) {
                 case 'oojInfections': lookupList = oojInfectionList; break;
                 case 'oojActivities': lookupList = oojActivityList; break;
                 case 'methodsOfTransmitting': lookupList = methodsOfTransmissionList; break;
                 case 'acceptableForPiis': lookupList = acceptablePiisData; break; // Assuming acceptablePiisData exists
                 default: return "Unknown Field";
             }

             return ids.map(id => {
                 const item = lookupList.find(d => d.id === id);
                 return item ? item.name : `ID ${id}`;
             }).join(', ');
         };
     }

     function createPointOfContactsTemplate() {
         return function(dataItem) {
             const ids = dataItem.pointOfContacts; // Expecting array of IDs
             if (!ids || ids.length === 0) return '—';

             // Use allJurisdictionList to find user details (assuming it contains users, which it doesn't yet)
             // *** THIS NEEDS ADJUSTMENT - contactsData is not globally fetched by default anymore ***
             // For now, just display IDs until contact fetching is finalized
             return ids.map(id => `Contact ID ${id}`).join(', ');
             /*
             return ids.map(id => {
                 // Find the contact in a globally available list (e.g., fetched during init or on demand)
                 const contact = contactsData.find(c => c.id === id); // Replace contactsData if needed
                 return contact ? `${contact.first_name} ${contact.last_name}` : `ID ${id}`;
             }).join(', ');
             */
         };
     }

     function createSingleSelectEditor(container, options, config) {
         $('<input required name="' + config.fieldName + '"/>') // Added required
             .appendTo(container)
             .kendoDropDownList({
                 dataTextField: "name",
                 dataValueField: "id",
                 dataSource: config.dataSource, // e.g., oojInfectionList
                 optionLabel: config.placeholder || "Select...",
                  // Value should be the first ID in the array (or null if empty)
                 value: (options.model[config.fieldName] && options.model[config.fieldName].length > 0) ? options.model[config.fieldName][0] : null,
                 change: function(e) {
                      // Model expects an array, even for single select
                     const value = this.value();
                     options.model.set(config.fieldName, value ? [parseInt(value, 10)] : []);
                 }
             }).data("kendoDropDownList");
     }

     function createMultiSelectEditor(container, options, config) {
         $('<input name="' + config.fieldName + '"/>')
             .appendTo(container)
             .kendoMultiSelect({
                 dataTextField: "name",
                 dataValueField: "id",
                 dataSource: config.dataSource, // e.g., oojActivityList
                 placeholder: config.placeholder || "Select...",
                 value: options.model[config.fieldName] || [], // Expects array of IDs
                 valuePrimitive: true, // Work with IDs
                 autoClose: false,
                 change: function(e) {
                     // Model expects array of IDs
                     options.model.set(config.fieldName, this.value());
                 }
             }).data("kendoMultiSelect");
     }

      function createPointOfContactsEditor(container, options) {
         // *** This editor needs access to the list of contacts for the CURRENTLY selected jurisdiction ***
         // It cannot reliably use a single global list anymore.
         // Option 1: Pass the correct contact list dynamically (complex).
         // Option 2: Fetch contacts within the editor (inefficient).
         // Option 3 (Chosen): Use a placeholder and log a warning. Requires separate user management.

         logger.warn("PointOfContactsEditor: Cannot dynamically determine correct contacts for the dropdown in this context. Displaying placeholder.");

         $('<input name="' + options.field + '" disabled />') // Disable for now
             .appendTo(container)
             .kendoMultiSelect({
                 placeholder: "Select Contacts (Requires User Mgmt)",
                 dataSource: [], // Initially empty
                 value: options.model.pointOfContacts || [],
                 valuePrimitive: true
             });

         // To make this work properly, the contactsData source for the MultiSelect
         // would need to be updated whenever the grid's data source reads,
         // ensuring it only shows contacts for the jurisdiction being edited.
         // This is non-trivial with the current setup.
     }

    // GRID INITIALIZATION
    oojJurisdictionGrid = $("#oojJurisdictionGrid").kendoGrid({
        dataSource: oojDataSource,
        autoBind: false, // Load data only when .read() is called
        scrollable: true,  // Enable scrolling
        height: 500,       // Set a fixed height (adjust px value as needed for ~10 rows)
        sortable: true,
        pageable: false,
        toolbar: ["excel", "search"],
        search: { fields: [ /* Add relevant fields */ "jurisdictionName", "notes", "oojEmail" ] },
        columns: [
             { field: "jurisdictionName", title: "Jurisdiction Name", width: 140 },
             { field: "oojInfections", title: "Infection", width: 140, template: createTaxonomyTemplate("oojInfections", false), editor: (c, o) => createSingleSelectEditor(c, o, {fieldName: "oojInfections", dataSource: oojInfectionList, placeholder: "Select..."}) },
             { field: "oojActivities", title: "Activity", width: 140, template: createTaxonomyTemplate("oojActivities"), editor: (c, o) => createMultiSelectEditor(c, o, {fieldName: "oojActivities", dataSource: oojActivityList, placeholder: "Select..."}) },
             {
                 field: "lastDateOfExposure",
                 title: "Last Date of Exposure",
                 width: 140,
                 headerTemplate: "Last Date of Exposure <span class='header-tooltip-icon'>&#9432;</span>",
                 headerAttributes: { "data-tooltip-content": "Timeframe within which a partner/contact's exposure to an infection is eligible for investigation (e.g. syphilis exposure that occurred within the past 90 days). Complete this when the Activity is Partner Services: Partner/Contact." }
             },
             {
                 field: "dispositionsReturned",
                 title: "Dispo/Info Returned",
                 width: 140,
                 headerTemplate: "Dispo/Info Returned <span class='header-tooltip-icon'>&#9432;</span>",
                 headerAttributes: { "data-tooltip-content": "Indicate if/when you will return a disposition or information for requested activities." }
             },
             { field: "methodsOfTransmitting", title: "Method(s) of Transmitting", width: 140, template: createTaxonomyTemplate("methodsOfTransmitting"), editor: (c, o) => createMultiSelectEditor(c, o, {fieldName: "methodsOfTransmitting", dataSource: methodsOfTransmissionList, placeholder: "Select..."}) },
             {
                 field: "acceptableForPiis",
                 title: "Acceptable for PIIs",
                 width: 140,
                 template: createTaxonomyTemplate("acceptableForPiis"),
                 headerTemplate: "Acceptable for PIIs <span class='header-tooltip-icon'>&#9432;</span>",
                 headerAttributes: { "data-tooltip-content": "Personally Identifiable Information. Please only transmit confidential patient information via one of these designated methods." },
                 editor: (c, o) => createMultiSelectEditor(c, o, {fieldName: "acceptableForPiis", dataSource: acceptablePiisData, placeholder: "Select..."})
             },
             { field: "oojPhone", title: "Phone", width: 140, template: formatPhoneTemplate },
             { field: "oojFax", title: "Fax", width: 140, template: formatPhoneTemplate },
             { field: "oojEmail", title: "Email", width: 140 },
             { field: "pointOfContacts", title: "Point of Contact", width: 140, template: createPointOfContactsTemplate(), editor: createPointOfContactsEditor },
             { field: "notes", title: "Notes", width: 140 }
            // { command: ["edit", "destroy"], title: "&nbsp;", width: "180px" } // Add commands if needed
        ],
        excelExport: function (e) {
            // Simplified Excel Export - Needs adjustment based on final data structure
            logger.info("Excel export triggered for OOJ Grid.");
            var workbook = new kendo.ooxml.Workbook({
                sheets: [{
                    columns: [ // Define columns for export
                        { autoWidth: true }, { autoWidth: true }, { autoWidth: true },
                        { autoWidth: true }, { autoWidth: true }, { autoWidth: true },
                        { autoWidth: true }, { autoWidth: true }, { autoWidth: true },
                        { autoWidth: true }, { autoWidth: true }, { autoWidth: true }
                    ],
                    title: "OOJ Details",
                    rows: [] // Placeholder - Rows need to be built manually
                }]
            });

            // Build header row
             var headers = [
                 "Jurisdiction Name", "OOJ Infections", "OOJ Activities",
                 "Last Date of Exposure", "Dispositions Returned",
                 "Methods of Transmitting", "Acceptable for PIIs",
                 "Phone", "Fax", "Email",
                 "Point of Contacts", "Notes"
             ];
            var headerRow = { cells: headers.map(h => ({ value: h, background: "#7a7a7a", color: "#ffffff", bold: true })) };
            workbook.sheets[0].rows.push(headerRow);

             // Manually build data rows using templates/lookup functions
             var gridData = e.sender.dataSource.view(); // Use view() to get current page/filtered data
             var infectionTemplateFn = createTaxonomyTemplate("oojInfections", false);
             var activityTemplateFn = createTaxonomyTemplate("oojActivities");
             var methodsTemplateFn = createTaxonomyTemplate("methodsOfTransmitting");
             var piiTemplateFn = createTaxonomyTemplate("acceptableForPiis");
             var pocTemplateFn = createPointOfContactsTemplate(); // Uses placeholder currently

             gridData.forEach(dataItem => {
                 var dataRow = {
                     cells: [
                         { value: dataItem.jurisdictionName || "" },
                         { value: infectionTemplateFn(dataItem) },
                         { value: activityTemplateFn(dataItem) },
                         { value: dataItem.lastDateOfExposure || "" },
                         { value: dataItem.dispositionsReturned || "" },
                         { value: methodsTemplateFn(dataItem) },
                         { value: piiTemplateFn(dataItem) },
                         { value: formatPhoneTemplate(dataItem, "oojPhone") }, // Use template helper
                         { value: formatPhoneTemplate(dataItem, "oojFax") }, // Use template helper
                         { value: dataItem.oojEmail || "" },
                         { value: pocTemplateFn(dataItem) }, // Uses placeholder currently
                         { value: dataItem.notes || "" }
                     ]
                 };
                 workbook.sheets[0].rows.push(dataRow);
             });


            kendo.saveAs({
                dataURI: workbook.toDataURL(),
                fileName: "OOJ_Details_Export.xlsx"
            });
            e.preventDefault(); // Prevent default export
       }
    }).data("kendoGrid");

    // --- ADD TOOLTIP INITIALIZATION FOR HEADERS ---
    $("#oojJurisdictionGrid .k-grid-header").kendoTooltip({
        filter: ".header-tooltip-icon", // Match only the icons in headers
        position: "bottom",
        content: function(e) {
            var th = $(e.target).closest('th');
            // Read from data-tooltip-content set in headerAttributes
            var tooltipContent = th.data("tooltip-content") || $(e.target).parent().data("tooltip-content");
            logger.info("Header Tooltip Hover:", e.target, "Content:", tooltipContent); // Optional log
            return tooltipContent || "No description";
        },
        width: 200,
        showAfter: 750 // Delay before showing
    });
    // --- END TOOLTIP INITIALIZATION ---

    logger.info('OOJ Grid Initialized (REST).');
} // End initializeOojGrid


// Initialize the Contact grid - Uses REST API DataSource
function initializeContactGrid() {
    // Role templates need global lists (hivRoleList, stiRoleList) populated
    function formatRolesTemplate(fieldName) {
        return function(dataItem) {
            const roleIds = dataItem.acf?.[fieldName];
            const roleList = fieldName === 'hiv_role' ? hivRoleList : stiRoleList;
            if (!roleIds || roleIds.length === 0) return "—";
            return roleIds.map(id => {
                const role = roleList.find(r => r.id === id);
                return role ? role.name : `ID ${id}`;
            }).join(", ");
        };
    }

    // --- Contact Grid DataSource ---
    var contactDataSource = new kendo.data.DataSource({
         transport: {
             read: {
                 url: function() {
                     const baseUrl = stdBaseUrl + "/users";
                      // Request fields needed for the grid display and potential editing
                     const fields = "_fields=id,first_name,last_name,email,acf";
                     const context = "context=edit"; // Needed to retrieve ACF fields
                     const perPage = "per_page=3000"; // Use max limit

                     if (selectedJurisdictionId && selectedJurisdictionId !== "ALL") {
                         const jurisdictionId = parseInt(selectedJurisdictionId, 10);
                         if (!isNaN(jurisdictionId)) {
                              // Filter by ACF field: acf_{field_name}={value}
                             const filter = `acf_user_jurisdiction=${jurisdictionId}`;
                             const specificUrl = `${baseUrl}?${fields}&${context}&${filter}&${perPage}`;
                             logger.info(`Contact Grid: Reading specific jurisdiction ID: ${jurisdictionId} via URL: ${specificUrl}`);
                             return specificUrl;
                         } else {
                             logger.warn(`Contact Grid: Invalid jurisdiction ID ${selectedJurisdictionId}. Reading ALL.`);
                             const allUrl = `${baseUrl}?${fields}&${context}&${perPage}`;
                             return allUrl;
                         }
                     } else if (selectedJurisdictionId === "ALL") {
                         const allUrl = `${baseUrl}?${fields}&${context}&${perPage}`;
                         logger.info(`Contact Grid: Reading ALL users via URL: ${allUrl}`);
                         return allUrl;
                     } else {
                         logger.warn("Contact Grid: No jurisdiction selected. Returning null.");
                         return null; // Don't load if no selection
                     }
                 },
                 dataType: "json",
                 beforeSend: addNonceToAjax
             }
             // NOTE: Create, Update, Destroy transport operations are NOT included here.
             // They would be similar to the User Grid in My Jurisdiction v2 if needed.
         },
         schema: {
             model: {
                 id: "id", // WP User ID is the model ID
                 fields: {
                     id: { editable: false, nullable: true },
                     first_name: { type: "string", validation: { required: true } },
                     last_name: { type: "string", validation: { required: true } },
                     email: { type: "string" }, // Email usually not editable here, depends on requirements
                     // ACF fields nested
                     acf: {
                         type: "object",
                         defaultValue: { user_jurisdiction: null, hiv_role: [], sti_role: [], user_phone: "", user_fax: "", notes_sti_hiv: "" },
                         parse: function(acfData) { // Ensure defaults if ACF is missing/incomplete
                             acfData = acfData || {};
                             return {
                                user_jurisdiction: acfData.user_jurisdiction ? parseInt(acfData.user_jurisdiction, 10) : null,
                                hiv_role: Array.isArray(acfData.hiv_role) ? acfData.hiv_role.map(id=>parseInt(id,10)) : [],
                                sti_role: Array.isArray(acfData.sti_role) ? acfData.sti_role.map(id=>parseInt(id,10)) : [],
                                user_phone: acfData.user_phone || "",
                                user_fax: acfData.user_fax || "",
                                notes_sti_hiv: acfData.notes_sti_hiv || ""
                             };
                         }
                     }
                 }
             },
             parse: function(response) {
                 logger.info("Contact Grid Parse: Received response:", response);
                 if (!Array.isArray(response)) {
                     logger.warn("Contact Grid Parse: Expected an array, received:", response);
                     return [];
                 }
                 // Ensure ACF object and its role arrays exist with correct types
                 return response.map(user => {
                     user.acf = user.acf || {};
                     user.acf.user_jurisdiction = user.acf.user_jurisdiction ? parseInt(user.acf.user_jurisdiction, 10) : null;
                     user.acf.hiv_role = Array.isArray(user.acf.hiv_role) ? user.acf.hiv_role.map(id=>parseInt(id,10)) : [];
                     user.acf.sti_role = Array.isArray(user.acf.sti_role) ? user.acf.sti_role.map(id=>parseInt(id,10)) : [];
                     user.acf.user_phone = user.acf.user_phone || "";
                     user.acf.user_fax = user.acf.user_fax || "";
                     user.acf.notes_sti_hiv = user.acf.notes_sti_hiv || "";
                     return user;
                 });
             },
             error: function(e) {
                 logger.error("Contact Grid DataSource Error:", e);
                 let message = "Error loading contacts.";
                  if (e.xhr && e.xhr.responseJSON && e.xhr.responseJSON.message) {
                      message = e.xhr.responseJSON.message;
                  } else if (e.errors) { message = Array.isArray(e.errors) ? e.errors.join(", ") : String(e.errors); }
                  alert(message);
                  var grid = $("#contactGrid").data("kendoGrid");
                  if (grid) { grid.cancelChanges(); }
             }
         },
         sort: { field: "last_name", dir: "asc" } // Default sort
    });
    // --- End Contact Grid DataSource ---

    contactGrid = $("#contactGrid").kendoGrid({
      dataSource: contactDataSource, // Use the new REST DataSource
      autoBind: false, // Do not bind on initialization, wait for dropdown change
      toolbar: ["excel", "search"],
      search: { fields: ["first_name", "last_name", "email", "acf.user_phone", "acf.user_fax", "acf.notes_sti_hiv"] },
      sortable: true,
      pageable: false, // Keep pageable false unless you specifically want Kendo paging
      scrollable: true,  // Enable scrolling
      height: 500,       // Set a fixed height (adjust px value as needed for ~10 rows)
      excel: {
        fileName: "STD_Contact_Board_Export.xlsx",
        allPages: true // Export all data loaded by the DataSource
      },
      columns: [
        {
          field: "acf.user_jurisdiction",
          title: "Jurisdiction",
          width: 140,
          template: function (dataItem) { return getJurisdictionName(dataItem.acf?.user_jurisdiction); },
          exportable: true,
          encoded: false
        },
        { field: "first_name", title: "First Name", width: 140 },
        { field: "last_name", title: "Last Name", width: 140 },
        { field: "email", title: "Email", width: 140 },
        { field: "acf.user_phone", title: "Phone", width: 140, template: formatPhoneTemplate },
        { field: "acf.user_fax", title: "Fax", width: 140, template: formatPhoneTemplate },
        { field: "acf.hiv_role", title: "HIV Roles", width: 140, template: formatRolesTemplate('hiv_role'), exportable: { text: true } },
        { field: "acf.sti_role", title: "STI Roles", width: 140, template: formatRolesTemplate('sti_role'), exportable: { text: true } },
        { field: "acf.notes_sti_hiv", title: "Notes", width: 140 },
      ],
      excelExport: function (e) {
          // Use a similar manual export building process as OOJ grid if complex formatting/lookups needed
          // Or rely on Kendo's default export if column templates aren't too complex
           var sheet = e.workbook.sheets[0];
           // Example: Manually set Jurisdiction name for export if needed
           for (var rowIndex = 1; rowIndex < sheet.rows.length; rowIndex++) {
               var row = sheet.rows[rowIndex];
               var dataItem = e.sender.dataSource.view()[rowIndex - 1]; // Get corresponding data item
               var jurisdictionCellIndex = e.sender.columns.findIndex(col => col.field === "acf.user_jurisdiction");
               var hivRoleCellIndex = e.sender.columns.findIndex(col => col.field === "acf.hiv_role");
               var stiRoleCellIndex = e.sender.columns.findIndex(col => col.field === "acf.sti_role");
               var phoneCellIndex = e.sender.columns.findIndex(col => col.field === "acf.user_phone");
               var faxCellIndex = e.sender.columns.findIndex(col => col.field === "acf.user_fax");


               if (jurisdictionCellIndex > -1) {
                   row.cells[jurisdictionCellIndex].value = getJurisdictionName(dataItem.acf?.user_jurisdiction);
               }
               if (hivRoleCellIndex > -1) {
                   row.cells[hivRoleCellIndex].value = formatRolesTemplate('hiv_role')(dataItem); // Use template fn
               }
               if (stiRoleCellIndex > -1) {
                    row.cells[stiRoleCellIndex].value = formatRolesTemplate('sti_role')(dataItem); // Use template fn
               }
                if (phoneCellIndex > -1) {
                    row.cells[phoneCellIndex].value = formatPhoneTemplate(dataItem, 'user_phone'); // Use template fn
                }
                if (faxCellIndex > -1) {
                     row.cells[faxCellIndex].value = formatPhoneTemplate(dataItem, 'user_fax'); // Use template fn
                }
               // Add other columns as needed
           }
           logger.info("Contact Grid Excel export customized.");
      }
    }).data("kendoGrid");
    logger.info("Contact Grid initialized (REST).");
 }

 // Update jurisdiction grid with selected jurisdiction info (uses pre-fetched list)
 function updateJurisdictionGrid(selectedId) {
    logger.info("Updating jurisdiction info grid for ID:", selectedId);
    let gridData = [];

    if (selectedId && selectedId !== "ALL") {
        const numericId = parseInt(selectedId, 10);
        const jurisdiction = allJurisdictionList.find(j => j.id === numericId);

        if (jurisdiction) {
            gridData = [{
                id: jurisdiction.id, // Include id
                title: jurisdiction.title?.rendered || "N/A",
                fips_code: jurisdiction.acf?.fips_code || "N/A",
                agency_name: jurisdiction.acf?.agency_name || "N/A",
                address_jurisdiction: jurisdiction.acf?.address_jurisdiction || "N/A",
                phone_jurisdiction: jurisdiction.acf?.phone_jurisdiction || "N/A",
                modified: jurisdiction.modified || null,
            }];
        } else {
            logger.warn(`Jurisdiction data not found in global list for ID: ${selectedId}`);
            gridData = [{ title: "Jurisdiction Not Found", fips_code: "N/A", agency_name: "N/A", address_jurisdiction: "N/A", phone_jurisdiction: "N/A", modified: null }];
        }
    } else {
         // Handle "ALL" or cleared selection - show default N/A state
         const message = selectedId === "ALL" ? "N/A (ALL selected)" : "N/A (No specific jurisdiction selected)";
         gridData = [{ title: message, fips_code: "N/A", agency_name: "N/A", address_jurisdiction: "N/A", phone_jurisdiction: "N/A", modified: null }];
    }

    if (jurisdictionGrid && jurisdictionGrid.dataSource) {
        jurisdictionGrid.dataSource.data(gridData);
    } else {
        logger.error("Jurisdiction Info Grid or its dataSource is not initialized.");
    }
  }

// Helper function for formatting phone numbers in templates
function formatPhoneTemplate(dataItem, fieldName = null) {
    let rawValue = null;
    // If fieldName is provided (for direct use), get value from potentially nested ACF
    if (fieldName) {
       rawValue = dataItem.acf ? dataItem.acf[fieldName] : dataItem[fieldName];
    } else {
        // If no fieldName, assume dataItem *is* the phone number (less common)
        rawValue = dataItem;
    }

    if (typeof rawValue === 'string' || typeof rawValue === 'number') {
        const digits = String(rawValue).replace(/\D/g, '');
        if (digits.length === 10) {
            return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6, 10)}`;
        } else if (digits.length > 0) {
             return digits; // Return cleaned digits if not 10 digits
        }
    }
    // Return empty string if invalid or empty
    return ""; // Changed from "—"
}


// Helper function to get Jurisdiction Name from the global list
function getJurisdictionName(jurisdictionId) {
    if (!jurisdictionId) return "N/A";
    const idToFind = parseInt(jurisdictionId, 10);
    if (isNaN(idToFind)) return "Invalid ID";
    var jurisdiction = allJurisdictionList.find(j => j.id === idToFind);
    return jurisdiction ? (jurisdiction.title?.rendered || "Unknown Name") : "Unknown ID";
}

</script>
