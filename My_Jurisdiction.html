<script>
	  
    // GraphQL queries for jurisdiction data
    var READ_JURISDICTION_QUERY = `
    query GetJurisdiction($databaseId: Int!) {
      jurisdictions(where: {id: $databaseId}) {
        edges {
          node {
            id
            databaseId
            title
            jurisdictionDetails {
              addressJurisdiction
              agencyName
              faxJurisdiction
              fipsCode
              phoneJurisdiction
            }
            modified
          }
        }
      }
    }
    `;
    
    var UPDATE_JURISDICTION_QUERY = `
    mutation UpdateJurisdiction($input: UpdateJurisdictionInput!) {
      updateJurisdiction(input: $input) {
        jurisdiction {
          id
          databaseId
          title
          jurisdictionDetails {
            addressJurisdiction
            agencyName
            faxJurisdiction
            fipsCode
            phoneJurisdiction
          }
        }
      }
    }
    `;
  
    var CREATE_JURISDICTION_QUERY = `
    mutation CreateJurisdiction($input: CreateJurisdictionInput!) {
      createJurisdiction(input: $input) {
        jurisdiction {
          id
          databaseId
          title
          jurisdictionDetails {
            addressJurisdiction
            agencyName
            faxJurisdiction
            fipsCode
            phoneJurisdiction
          }
        }
      }
    }
    `;
  
    var DELETE_JURISDICTION_QUERY = `
    mutation DeleteJurisdiction($input: DeleteJurisdictionInput!) {
      deleteJurisdiction(input: $input) {
        jurisdiction {
          id
          databaseId
        }
        deleted
      }
    }
    `;
    
    var READ_USERS_QUERY = `
    query GetUsersByJurisdiction($jurisdictionId: Int!) {
      users(where: {jurisdictionDatabaseId: $jurisdictionId},
      first: 1000) {
        nodes {
          firstName
          lastName
          email
          stdContactDetails {
            confidentialPhone
            userPhone
            userFax
            notesStiHiv
            stiRole {
              nodes {
                name
                id
                databaseId
              }
            }
            hivRole {
              nodes {
                name
                id
                databaseId
              }
            }
          }
          id
          databaseId
        }
      }
    }
    `;
  
    var UPDATE_USER_QUERY = `
    mutation UpdateUserStdContact($input: UpdateUserStdContactInput!) {
      updateUserStdContact(input: $input) {
        user {
          id
          databaseId
          firstName
          lastName
          email
          stdContactDetails {
            confidentialPhone
            userPhone
            userFax
            notesStiHiv
            hivRole {
              nodes {
                id
                databaseId
                name
              }
            }
            stiRole {
              nodes {
                id
                databaseId
                name
              }
            }
          }
        }
      }
    }
    `;
  
    var CREATE_USER_QUERY = `
    mutation CreateUser($input: CreateUserInput!) {
      createUser(input: $input) {
        user {
          id
          databaseId
          firstName
          lastName
          email
          stdContactDetails {
            confidentialPhone
            userPhone
            userFax
            notesStiHiv
            hivRole {
              nodes {
                id
                databaseId
                name
              }
            }
            stiRole {
              nodes {
                id
                databaseId
                name
              }
            }
          }
        }
      }
    }
    `;
  
    var DELETE_USER_QUERY = `
    mutation DeleteUser($input: DeleteUserInput!) {
      deleteUser(input: $input) {
        deletedId
      }
    }
    `;
  
    var GET_HIV_ROLES_QUERY = `
    query GetHivRoles {
      hIVRoles {
        nodes {
          id
          databaseId
          name
        }
      }
    }
    `;
  
    var GET_STI_ROLES_QUERY = `
    query GetStiRoles {
      sTIRoles {
        nodes {
          name
          databaseId
          id
        }
      }
    }
    `;
  
    var GET_CURRENT_USER_JURISDICTION_QUERY = `
    query CurrentUserJurisdiction {
      viewer {
        stdContactDetails {
          userJurisdiction {
            nodes {
              databaseId
              id
              ... on Jurisdiction {
                id
                title
                jurisdictionDetails {
                  addressJurisdiction
                  agencyName
                  faxJurisdiction
                  fipsCode
                  phoneJurisdiction
                }
              }
            }
          }
        }
      }
    }
    `;
  
  // We're no longer using GraphQL for OOJ Detail operations
  // This section has been removed and replaced with WordPress REST API implementation
  
    // Global variables for storing reference data
    var hivRolesData = [];
    var stiRolesData = [];
    var currentJurisdictionId = null;
    var oojInfectionsData = [];
    var oojActivitiesData = [];
    var methodsTransmittingData = [];
    var acceptablePiisData = [];
    var contactsData = [];
    
    // Function to generate secure passwords with required complexity
    function generateSecurePassword() {
        var upperChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var lowerChars = 'abcdefghijklmnopqrstuvwxyz';
        var numbers = '0123456789';
        var specialChars = '!@#$%^&*()_+[]{}|;:,.<>?';
        
        var allChars = upperChars + lowerChars + numbers + specialChars;
        var password = '';
        
        // Ensure at least one of each required character type
        password += upperChars.charAt(Math.floor(Math.random() * upperChars.length));
        password += lowerChars.charAt(Math.floor(Math.random() * lowerChars.length));
        password += numbers.charAt(Math.floor(Math.random() * numbers.length));
        password += specialChars.charAt(Math.floor(Math.random() * specialChars.length));
        
        // Fill the rest with random characters
        for (var i = 0; i < 4; i++) {
            password += allChars.charAt(Math.floor(Math.random() * allChars.length));
        }
        
        // Shuffle the password characters
        return password.split('').sort(function() { 
            return 0.5 - Math.random(); 
        }).join('');
    }
  
    // Function to show notifications
    function showNotification(message, type = 'error') {
        if (window.kendo && kendo.ui.Notification) {
            const notification = new kendo.ui.Notification({
                position: { top: 30, right: 30 }
            });
            notification[type](message);
        } else {
            console[type === 'error' ? 'error' : 'log'](message);
        }
    }
  
    $(document).ready(function() {
        // First fetch current user's jurisdiction
        $.ajax({
            url: 'https://hivstiooj.cste.org/graphql',
            method: 'POST',
            data: JSON.stringify({ query: GET_CURRENT_USER_JURISDICTION_QUERY }),
            contentType: 'application/json',
            dataType: 'json',
            xhrFields: { withCredentials: true },
            headers: { 'Accept': 'application/json' }
        }).then(function(response) {
            if (response.errors) {
                console.error('GraphQL errors:', response.errors);
                showNotification('Error: ' + response.errors[0].message);
                return;
            }
  
            const jurisdictionNode = response?.data?.viewer?.stdContactDetails?.userJurisdiction?.nodes?.[0];
            if (!jurisdictionNode) {
                showNotification("Could not determine user's jurisdiction");
                return;
            }
  
            currentJurisdictionId = jurisdictionNode.databaseId;
            console.log('Using jurisdictionId:', currentJurisdictionId);
  
            // Then fetch reference data for all grids
            Promise.all([
                $.ajax({
                    url: 'https://hivstiooj.cste.org/graphql',
                    method: 'POST',
                    data: JSON.stringify({ query: GET_HIV_ROLES_QUERY }),
                    contentType: 'application/json',
                    dataType: 'json',
                    xhrFields: { withCredentials: true }
                }),
                $.ajax({
                    url: 'https://hivstiooj.cste.org/graphql',
                    method: 'POST',
                    data: JSON.stringify({ query: GET_STI_ROLES_QUERY }),
                    contentType: 'application/json',
                    dataType: 'json',
                    xhrFields: { withCredentials: true }
                }),
                // We no longer need to fetch OOJ data via GraphQL - will use REST API instead
                $.ajax({
                    url: 'https://hivstiooj.cste.org/graphql',
                    method: 'POST',
                    data: JSON.stringify({ 
                        query: READ_USERS_QUERY,
                        variables: { "jurisdictionId": parseInt(currentJurisdictionId, 10) }
                    }),
                    contentType: 'application/json',
                    dataType: 'json',
                    xhrFields: { withCredentials: true }
                })
            ]).then(function(results) {
                // Store reference data
                if (results[0].data && results[0].data.hIVRoles) {
                    hivRolesData = results[0].data.hIVRoles.nodes;
                }
                if (results[1].data && results[1].data.sTIRoles) {
                    stiRolesData = results[1].data.sTIRoles.nodes;
                }
              // Now fetch OOJ-related data using WordPress REST API instead of GraphQL
              Promise.all([
                  // Fetch OOJ Infections
                  $.ajax({
                      url: 'https://hivstiooj.cste.org/wp-json/wp/v2/acf-ooj-infection?per_page=100',
                      method: 'GET',
                      xhrFields: { withCredentials: true },
                      beforeSend: function(xhr) {
                          if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                              xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                          }
                      }
                  }).then(null, function(error) {
                      console.error("OOJ Infections REST API error:", error);
                      return []; // Return empty array on error
                  }),
                  
                  // Fetch OOJ Activities
                  $.ajax({
                      url: 'https://hivstiooj.cste.org/wp-json/wp/v2/acf-ooj-activity?per_page=100',
                      method: 'GET',
                      xhrFields: { withCredentials: true },
                      beforeSend: function(xhr) {
                          if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                              xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                          }
                      }
                  }).then(null, function(error) {
                      console.error("OOJ Activities REST API error:", error);
                      return []; // Return empty array on error
                  }),
                  
                  // Fetch Methods of Transmitting
                  $.ajax({
                      url: 'https://hivstiooj.cste.org/wp-json/wp/v2/iccr_method-of-transmitting?per_page=100',
                      method: 'GET',
                      xhrFields: { withCredentials: true },
                      beforeSend: function(xhr) {
                          if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                              xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                          }
                      }
                  }).then(null, function(error) {
                      console.error("Methods of Transmitting REST API error:", error);
                      return []; // Return empty array on error
                  }),
                  
                  // Fetch Acceptable for PIIs
                  $.ajax({
                      url: 'https://hivstiooj.cste.org/wp-json/wp/v2/acceptable-for-pii?per_page=100',
                      method: 'GET',
                      xhrFields: { withCredentials: true },
                      beforeSend: function(xhr) {
                          if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                              xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                          }
                      }
                  }).then(null, function(error) {
                      console.error("Acceptable for PIIs REST API error:", error);
                      return []; // Return empty array on error
                  })
              ]).then(function(oojResults) {
                  // Process OOJ Infections from REST API
                  if (Array.isArray(oojResults[0]) && oojResults[0].length > 0) {
                      oojInfectionsData = oojResults[0].map(term => ({
                          id: term.id,
                          databaseId: term.id,
                          name: term.name
                      }));
                      console.log('Loaded OOJ Infections data from REST API:', oojInfectionsData);
                  } else {
                      console.warn('OOJ Infections fetch returned empty or invalid data');
                      oojInfectionsData = [];
                      showNotification('Failed to load OOJ Infections data', 'warning');
                  }
                  
                  // Process OOJ Activities from REST API
                  if (Array.isArray(oojResults[1]) && oojResults[1].length > 0) {
                      oojActivitiesData = oojResults[1].map(term => ({
                          id: term.id,
                          databaseId: term.id,
                          name: term.name
                      }));
                      console.log('Loaded OOJ Activities data from REST API:', oojActivitiesData);
                  } else {
                      console.warn('OOJ Activities fetch returned empty or invalid data');
                      oojActivitiesData = [];
                      showNotification('Failed to load OOJ Activities data', 'warning');
                  }
                  
                  // Process Methods of Transmitting from REST API
                  if (Array.isArray(oojResults[2]) && oojResults[2].length > 0) {
                      methodsTransmittingData = oojResults[2].map(term => ({
                          id: term.id,
                          databaseId: term.id,
                          name: term.name
                      }));
                      console.log('Loaded Methods of Transmitting data from REST API:', methodsTransmittingData);
                  } else {
                      console.warn('Methods of Transmitting fetch returned empty or invalid data');
                      methodsTransmittingData = [];
                      showNotification('Failed to load Methods of Transmitting data', 'warning');
                  }
                  
                  // Process Acceptable for PIIs from REST API
                  if (Array.isArray(oojResults[3]) && oojResults[3].length > 0) {
                      acceptablePiisData = oojResults[3].map(term => ({
                          id: term.id,
                          databaseId: term.id,
                          name: term.name
                      }));
                      console.log('Loaded Acceptable for PIIs data from REST API:', acceptablePiisData);
                  } else {
                      console.warn('Acceptable for PIIs fetch returned empty or invalid data');
                      acceptablePiisData = [];
                      showNotification('Failed to load Acceptable for PIIs data', 'warning');
                  }
              });
              
                // We already processed contactsData above, no need to do it again
                if (results[2].data && results[2].data.users) {
                    contactsData = results[2].data.users.nodes;
                    // ADD THIS LOG: Inspect the data source for the editor
                  console.log("Checking contactsData structure (first few items):", JSON.stringify(contactsData.slice(0, 3), null, 2));
                }
  
                // Initialize grids
                initJurisdictionGrid();
                initUsersGrid();
                initOojGrid();
            }).catch(function(error) {
                console.error("Error fetching roles:", error);
                showNotification("Failed to load roles data");
            });
        }).catch(function(error) {
            console.error("Error getting jurisdiction:", error);
            showNotification("Failed to determine user's jurisdiction");
        });
  
        function initJurisdictionGrid() {
            // JURISDICTION GRID DATASOURCE
            var jurisdictionDataSource = new kendo.data.DataSource({
                autoSync: false, // Disable auto sync - require manual save
                transport: {
                    create: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function(model) {
                            return {
                                query: CREATE_JURISDICTION_QUERY,
                                variables: {
                                    "input": {
                                        "title": model.title.rendered,
                                        "status": "publish",
                                        "agencyName": model.jurisdictionDetails.agencyName,
                                        "addressJurisdiction": model.jurisdictionDetails.addressJurisdiction,
                                        "phoneJurisdiction": model.jurisdictionDetails.phoneJurisdiction,
                                        "fipsCode": model.jurisdictionDetails.fipsCode,
                                        "faxJurisdiction": model.jurisdictionDetails.faxJurisdiction
                                    }
                                }
                            };
                        }
                    },
                    read: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function() {
                            return {
                                query: READ_JURISDICTION_QUERY,
                                variables: { "databaseId": currentJurisdictionId }
                            };
                        }
                    },
                    update: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function(model) {
                            const globalId = btoa(`post:${model.databaseId}`);
                            return {
                                query: UPDATE_JURISDICTION_QUERY,
                                variables: {
                                    "input": {
                                        "id": globalId,
                                        "title": model.title.rendered,
                                        "agencyName": model.jurisdictionDetails.agencyName,
                                        "addressJurisdiction": model.jurisdictionDetails.addressJurisdiction,
                                        "phoneJurisdiction": model.jurisdictionDetails.phoneJurisdiction,
                                        "fipsCode": model.jurisdictionDetails.fipsCode,
                                        "faxJurisdiction": model.jurisdictionDetails.faxJurisdiction
                                    }
                                }
                            };
                        }
                    },
                    destroy: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function(model) {
                            return {
                                query: DELETE_JURISDICTION_QUERY,
                                variables: {
                                    "input": {
                                        "id": model.id,
                                        "forceDelete": true
                                    }
                                }
                            };
                        }
                    },
                    parameterMap: function(options, operation) {
                        const payload = kendo.stringify({
                            query: options.query,
                            variables: options.variables
                        });
                        console.log('Sending jurisdiction payload:', payload);
                        return payload;
                    }
                },
                schema: {
                    data: function(response) {
                        console.log('Jurisdiction response received:', response);
                        if (response.errors && response.errors.length > 0) {
                            console.error('GraphQL errors:', response.errors);
                            showNotification('Error: ' + response.errors[0].message);
                            return [];
                        }
                        
                        var data = response.data;
                        if (!data) return [];
  
                        // Handle different response types
                        if (data.jurisdictions && data.jurisdictions.edges) {
                            return data.jurisdictions.edges.map(edge => {
                                const node = edge.node;
                                return {
                                    id: node.id,
                                    databaseId: node.databaseId,
                                    title: { rendered: node.title },
                                    modified: node.modified,
                                    jurisdictionDetails: node.jurisdictionDetails
                                };
                            });
                        }
                        else if (data.createJurisdiction && data.createJurisdiction.jurisdiction) {
                            const jurisdiction = data.createJurisdiction.jurisdiction;
                            return [{
                                id: jurisdiction.id,
                                databaseId: jurisdiction.databaseId,
                                title: { rendered: jurisdiction.title },
                                modified: new Date().toISOString(),
                                jurisdictionDetails: jurisdiction.jurisdictionDetails
                            }];
                        }
                        else if (data.updateJurisdiction && data.updateJurisdiction.jurisdiction) {
                            const jurisdiction = data.updateJurisdiction.jurisdiction;
                            return [{
                                id: jurisdiction.id,
                                databaseId: jurisdiction.databaseId,
                                title: { rendered: jurisdiction.title },
                                modified: new Date().toISOString(),
                                jurisdictionDetails: jurisdiction.jurisdictionDetails
                            }];
                        }
                        else if (data.deleteJurisdiction && data.deleteJurisdiction.deleted) {
                            return [];
                        }
                        
                        return [];
                    },
                    model: {
                        id: "id",
                        fields: {
                            id: { editable: false, nullable: true },
                            databaseId: { editable: false, nullable: true },
                            title: { defaultValue: { rendered: "" } },
                            modified: { type: "string", editable: false },
                            jurisdictionDetails: {
                                defaultValue: {
                                    agencyName: "",
                                    addressJurisdiction: "",
                                    phoneJurisdiction: "",
                                    fipsCode: "",
                                    faxJurisdiction: ""
                                }
                            }
                        }
                    }
                },
               
            });
  
            $("#juris_grid").kendoGrid({
                dataSource: jurisdictionDataSource,
                height: 175,
                sortable: true,
                toolbar: ["save", "cancel"],
                editable: "inline",
                save: function(e) {
                    console.log("Jurisdiction grid save event triggered", e);
                    // Manually sync when save is clicked
                    jurisdictionDataSource.sync();
                },
                columns: [
                    //{ field: "title.rendered", title: "Jurisdiction Name" },
                    //{ field: "jurisdictionDetails.fipsCode", title: "FIPS Code" },
                    { field: "jurisdictionDetails.agencyName", title: "Agency Name" },
                    { field: "jurisdictionDetails.addressJurisdiction", title: "Agency Address" },
                    { field: "jurisdictionDetails.phoneJurisdiction", title: "Agency Phone (Main)" },
                    { field: "jurisdictionDetails.faxJurisdiction", title: "Agency Fax" },
                    { command: ["edit"], title: "&nbsp;", width: "250px" }
                ]
            });
        }
  
        function initUsersGrid() {
            // USERS GRID DATASOURCE
            var usersDataSource = new kendo.data.DataSource({
                autoSync: false, // Disable auto sync - require manual save
                batch: false,   // Process updates immediately, not in batches
                transport: {
                    create: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function(model) {
                            // Extract role IDs and ensure integer format
                            const hivRoleIds = Array.isArray(model.hivRole) ? 
                                model.hivRole.map(role => {
                                    const id = typeof role === 'object' ? role.databaseId : role;
                                    return parseInt(id, 10);
                                }) : [];
                            
                            const stiRoleIds = Array.isArray(model.stiRole) ? 
                                model.stiRole.map(role => {
                                    const id = typeof role === 'object' ? role.databaseId : role;
                                    return parseInt(id, 10);
                                }) : [];
                            
                            // Generate a secure password for the new user
                            const securePassword = generateSecurePassword();
                            console.log('Generated secure password:', securePassword);
                            
                            // Generate username based on email (default) or first+last name
                            let username = "";
                            if (model.email) {
                                // Generate username from email by removing the domain part
                                username = model.email.split('@')[0];
                            } else if (model.firstName && model.lastName) {
                                // Generate username from first name + last name
                                username = (model.firstName + "." + model.lastName).toLowerCase();
                            } else {
                                // Fallback to a timestamp-based username
                                username = "user_" + new Date().getTime();
                            }
                            // Sanitize username (remove special chars and spaces)
                            username = username.replace(/[^a-zA-Z0-9._-]/g, "");
                            console.log('Generated username:', username);
                            
                            // Step 1: Create user with core fields only
                            console.log('CREATE USER with data:', model);
                            
                            // Store the full model data for the second step using closure variables
                            // Make these accessible to the schema.data callback later
                            window.tempUserCreationData = {
                                fullModel: {
                                    confidentialPhone: model.confidentialPhone || "",
                                    userPhone: model.userPhone || "",
                                    userFax: model.userFax || "",
                                    notesStiHiv: model.notesStiHiv || ""
                                },
                                fullHivRoleIds: hivRoleIds,
                                fullStiRoleIds: stiRoleIds
                            };
                            
                            // Only include the standard WordPress fields in the mutation
                            const createPayload = {
                                query: CREATE_USER_QUERY,
                                variables: {
                                    "input": {
                                        "username": username,
                                        "firstName": model.firstName || "",
                                        "lastName": model.lastName || "",
                                        "email": model.email || "",
                                        "password": securePassword
                                    }
                                }
                            };
                            
                            console.log('CREATE USER GraphQL payload:', JSON.stringify(createPayload, null, 2));
                            return createPayload;
                        }
                    },
                    read: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function() {
                            return {
                                query: READ_USERS_QUERY,
                                variables: { "jurisdictionId": parseInt(currentJurisdictionId, 10) }
                            };
                        }
                    },
                    update: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function(model) {
                            // Extract role IDs and ensure integer format
                            const hivRoleIds = Array.isArray(model.hivRole) ? 
                                model.hivRole.map(role => {
                                    const id = typeof role === 'object' ? role.databaseId : role;
                                    return parseInt(id, 10);
                                }) : [];
                            
                            const stiRoleIds = Array.isArray(model.stiRole) ? 
                                model.stiRole.map(role => {
                                    const id = typeof role === 'object' ? role.databaseId : role;
                                    return parseInt(id, 10);
                                }) : [];
                            
                            console.log('UPDATE USER with data:', model);
                            console.log('hivRoleIds:', hivRoleIds);
                            console.log('stiRoleIds:', stiRoleIds);
                            
                            return {
                                query: UPDATE_USER_QUERY,
                                variables: {
                                    "input": {
                                        "userId": parseInt(model.databaseId, 10),
                                        "firstName": model.firstName || "",
                                        "lastName": model.lastName || "",
                                        "email": model.email || "",
                                        "confidentialPhone": model.confidentialPhone || "",
                                        "userPhone": model.userPhone || "",
                                        "userFax": model.userFax || "",
                                        "notesStiHiv": model.notesStiHiv || "",
                                        "hivRole": hivRoleIds,
                                        "stiRole": stiRoleIds,
                                        "userJurisdiction": parseInt(currentJurisdictionId, 10)
                                    }
                                }
                            };
                        }
                    },
                    destroy: {
                        contentType: "application/json",
                        url: "https://hivstiooj.cste.org/graphql",
                        type: "POST",
                        data: function(model) {
                            return {
                                query: DELETE_USER_QUERY,
                                variables: {
                                    "input": {
                                        "id": model.id
                                        // forceDelete removed as it's not supported by the schema
                                    }
                                }
                            };
                        }
                    },
                    parameterMap: function(options, operation) {
                        console.log('parameterMap for users with operation:', operation, 'options:', options);
                        
                        // For update operations, make sure we're using the current model state
                        if (operation === 'update' && options.models) {
                            console.log('Preparing update for models:', options.models);
                        }
                        
                        const payload = kendo.stringify({
                            query: options.query,
                            variables: options.variables
                        });
                        console.log('Sending payload:', payload);
                        return payload;
                    }
                },
                schema: {
                    data: function(response) {
                        console.log('User response received:', response);
                        if (response.errors && response.errors.length > 0) {
                            console.error('GraphQL errors:', response.errors);
                            showNotification('Error: ' + response.errors[0].message);
                            return [];
                        }
                        
                        var data = response.data;
                        if (!data) return [];
  
                        // Handle user read operation
                        if (data.users && data.users.nodes) {
                            return data.users.nodes.map(node => {
                                return {
                                    id: node.id,
                                    databaseId: node.databaseId,
                                    firstName: node.firstName || "",
                                    lastName: node.lastName || "",
                                    email: node.email || "",
                                    confidentialPhone: node.stdContactDetails?.confidentialPhone || "",
                                    userPhone: node.stdContactDetails?.userPhone || "",
                                    userFax: node.stdContactDetails?.userFax || "",
                                    notesStiHiv: node.stdContactDetails?.notesStiHiv || "",
                                    hivRole: node.stdContactDetails?.hivRole?.nodes || [],
                                    stiRole: node.stdContactDetails?.stiRole?.nodes || []
                                };
                            });
                        }
                        // Handle user create operation
                        else if (data.createUser && data.createUser.user) {
                            const user = data.createUser.user;
                            
                            // Step 2: Now that user is created, update with custom fields
                            console.log('User created successfully, now updating custom fields...');
                            
                            // Get the stored data from step 1
                            const storedData = window.tempUserCreationData || {};
                            
                            // Create a shallow copy to avoid model mutation warnings
                            const newUser = {
                                id: user.id,
                                databaseId: user.databaseId,
                                firstName: user.firstName || "",
                                lastName: user.lastName || "",
                                email: user.email || "",
                                confidentialPhone: storedData.fullModel?.confidentialPhone || "",
                                userPhone: storedData.fullModel?.userPhone || "",
                                userFax: storedData.fullModel?.userFax || "",
                                notesStiHiv: storedData.fullModel?.notesStiHiv || "",
                                hivRole: [],  // Will be populated after update
                                stiRole: []   // Will be populated after update
                            };
                            
                            // Prepare the update mutation payload
                            const updatePayload = {
                                query: UPDATE_USER_QUERY,
                                variables: {
                                    "input": {
                                        "userId": user.databaseId,
                                        "confidentialPhone": storedData.fullModel?.confidentialPhone || "",
                                        "userPhone": storedData.fullModel?.userPhone || "",
                                        "userFax": storedData.fullModel?.userFax || "",
                                        "notesStiHiv": storedData.fullModel?.notesStiHiv || "",
                                        "hivRole": storedData.fullHivRoleIds || [],
                                        "stiRole": storedData.fullStiRoleIds || [],
                                        "userJurisdiction": parseInt(currentJurisdictionId, 10)
                                    }
                                }
                            };
                            
                            console.log('UPDATE USER GraphQL payload:', JSON.stringify(updatePayload, null, 2));
                            
                            // Clean up the temporary data
                            delete window.tempUserCreationData;
                            
                            // Send the update mutation to add the custom fields
                            $.ajax({
                                url: 'https://hivstiooj.cste.org/graphql',
                                method: 'POST',
                                contentType: 'application/json',
                                data: JSON.stringify(updatePayload),
                                dataType: 'json',
                                xhrFields: { withCredentials: true }
                            }).then(function(updateResponse) {
                                if (updateResponse.errors && updateResponse.errors.length > 0) {
                                    console.error('Error updating user custom fields:', updateResponse.errors);
                                    showNotification('Error updating user custom fields: ' + 
                                                     updateResponse.errors[0].message, 'warning');
                                } else {
                                    console.log('User custom fields updated successfully');
                                    
                                    // Update the local model with the roles if available
                                    if (updateResponse.data?.updateUserStdContact?.user?.stdContactDetails) {
                                        const details = updateResponse.data.updateUserStdContact.user.stdContactDetails;
                                        newUser.hivRole = details.hivRole?.nodes || [];
                                        newUser.stiRole = details.stiRole?.nodes || [];
                                    }
                                    
                                    // Refresh the grid to show updated data
                                    usersDataSource.read();
                                }
                            }).catch(function(error) {
                                console.error('AJAX error updating user custom fields:', error);
                                showNotification('Error updating user custom fields', 'error');
                            });
                            
                            return [newUser];
                        }
                        // Handle user update operation
                        else if (data.updateUserStdContact && data.updateUserStdContact.user) {
                            const user = data.updateUserStdContact.user;
                            return [{
                                id: user.id,
                                databaseId: user.databaseId,
                                firstName: user.firstName || "",
                                lastName: user.lastName || "",
                                email: user.email || "",
                                confidentialPhone: user.stdContactDetails?.confidentialPhone || "",
                                userPhone: user.stdContactDetails?.userPhone || "",
                                userFax: user.stdContactDetails?.userFax || "",
                                notesStiHiv: user.stdContactDetails?.notesStiHiv || "",
                                hivRole: user.stdContactDetails?.hivRole?.nodes || [],
                                stiRole: user.stdContactDetails?.stiRole?.nodes || []
                            }];
                        }
                        // Handle user delete operation
                        else if (data.deleteUser && data.deleteUser.deletedId) {
                            return [];
                        }
                        
                        return [];
                    },
                    model: {
                        id: "id",
                        fields: {
                            id: { editable: false, nullable: true },
                            databaseId: { editable: false, nullable: true },
                            firstName: { type: "string" },
                            lastName: { type: "string" },
                            email: { type: "string" },
                            confidentialPhone: { type: "string" },
                            userPhone: { type: "string" },
                            userFax: { type: "string" },
                            notesStiHiv: { type: "string" },
                            hivRole: { defaultValue: [] },
                            stiRole: { defaultValue: [] }
                        }
                    }
                },
               
                change: function(e) {
                    console.log('UsersDataSource change event:', e);
                }
            });
  
            $("#users_grid").kendoGrid({
                dataSource: usersDataSource,
              
                scrollable: false,
                sortable: true,
                toolbar: ["create"],
                editable: "inline",
                columns: [
                    { field: "firstName", title: "First Name", width: 120 },
                    { field: "lastName", title: "Last Name", width: 120 },
                    { field: "email", title: "Email", width: 180 },
                    { field: "confidentialPhone", title: "Confidential Phone", width: 150 },
                    { field: "userPhone", title: "Phone", width: 120 },
                    { field: "userFax", title: "Fax", width: 120 },
                    { field: "notesStiHiv", title: "Notes", width: 180 },
                    { 
                        field: "hivRole", 
                        title: "HIV Roles", 
                        width: 180,
                        template: function(dataItem) {
                            return dataItem.hivRole && dataItem.hivRole.length ? 
                                dataItem.hivRole.map(r => r.name).join(', ') : '—';
                        },
                        editor: function(container, options) {
                            $('<input name="hivRole" />')
                                .appendTo(container)
                                .kendoMultiSelect({
                                    placeholder: "Select HIV Roles...",
                                    dataTextField: "name",
                                    dataValueField: "databaseId",
                                    dataSource: hivRolesData,
                                    value: options.model.hivRole.map(role => 
                                        typeof role === 'object' ? role.databaseId : role),
                                    change: function(e) {
                                        const selectedValues = e.sender.value();
                                        options.model.hivRole = [];
                                        selectedValues.forEach(value => {
                                            const roleObj = hivRolesData.find(r => String(r.databaseId) === String(value));
                                            if (roleObj) {
                                                options.model.hivRole.push({ 
                                                    id: roleObj.id,
                                                    databaseId: roleObj.databaseId,
                                                    name: roleObj.name
                                                });
                                            }
                                        });
                                        
                                        // Mark as dirty to ensure update and trigger direct sync
                                        options.model.dirty = true;
                                        console.log("Model marked dirty after HIV role change");
                                    }
                                });
                        }
                    },
                    { 
                        field: "stiRole", 
                        title: "STI Roles", 
                        width: 180,
                        template: function(dataItem) {
                            return dataItem.stiRole && dataItem.stiRole.length ? 
                                dataItem.stiRole.map(r => r.name).join(', ') : '—';
                        },
                        editor: function(container, options) {
                            $('<input name="stiRole" />')
                                .appendTo(container)
                                .kendoMultiSelect({
                                    placeholder: "Select STI Roles...",
                                    dataTextField: "name",
                                    dataValueField: "databaseId",
                                    dataSource: stiRolesData,
                                    value: options.model.stiRole.map(role => 
                                        typeof role === 'object' ? role.databaseId : role),
                                    change: function(e) {
                                        const selectedValues = e.sender.value();
                                        options.model.stiRole = [];
                                        selectedValues.forEach(value => {
                                            const roleObj = stiRolesData.find(r => String(r.databaseId) === String(value));
                                            if (roleObj) {
                                                options.model.stiRole.push({ 
                                                    id: roleObj.id,
                                                    databaseId: roleObj.databaseId,
                                                    name: roleObj.name
                                                });
                                            }
                                        });
                                        
                                        // Mark as dirty to ensure update and trigger direct sync
                                        options.model.dirty = true;
                                        console.log("Model marked dirty after STI role change");
                                    }
                                });
                        }
                    },
                    { command: ["edit", "destroy"], title: "&nbsp;", width: "130px" }
                ]
            });
        }
    });
    
    // Generic template factory functions
    function createTaxonomyTemplate(fieldName) {
        return function(dataItem) {
            return dataItem[fieldName] && dataItem[fieldName].length ? 
                dataItem[fieldName].map(item => item.name).join(', ') : '—';
        };
    }
    
    function createPointOfContactsTemplate() {
    return function(dataItem) {
        // Access the first element of the array if it exists
        const contact = dataItem.pointOfContacts && dataItem.pointOfContacts.length > 0 ?
                        dataItem.pointOfContacts[0] : null;
        // Display the name or '—' if no contact is selected
        return contact ? `${contact.firstName} ${contact.lastName}` : '—';
    };
}

    
    // Generic editor factory functions for taxonomy fields
    function createSingleSelectEditor(container, options, config) {
        $(`<input name="${config.fieldName}" />`)
            .appendTo(container)
            .kendoDropDownList({
                placeholder: config.placeholder || "Select...",
                dataTextField: "name",
                dataValueField: "databaseId",
                dataSource: config.dataSource,
                value: (options.model[config.fieldName] || []).length > 0 ? 
                    (typeof options.model[config.fieldName][0] === 'object' ? 
                        options.model[config.fieldName][0].databaseId : 
                        options.model[config.fieldName][0]) : "",
                change: function(e) {
                    const selectedValue = e.sender.value();
                    options.model[config.fieldName] = [];
                    
                    if (selectedValue) {
                        const itemObj = config.dataSource.find(i => 
                            String(i.databaseId) === String(selectedValue));
                        
                        if (itemObj) {
                            options.model[config.fieldName].push({ 
                                id: itemObj.id,
                                databaseId: itemObj.databaseId,
                                name: itemObj.name
                            });
                        }
                    }
                    
                    // Call custom onChange handler if provided
                    if (config.onChange) {
                        config.onChange(e, options);
                    }
                }
            });
    }
    
    function createMultiSelectEditor(container, options, config) {
        const multiSelect = $(`<input name="${config.fieldName}" />`)
            .appendTo(container)
            .kendoMultiSelect({
                placeholder: config.placeholder || "Select...",
                dataTextField: "name",
                dataValueField: "databaseId",
                dataSource: config.dataSource,
                value: (options.model[config.fieldName] || []).map(item => 
                    typeof item === 'object' ? item.databaseId : item),
                itemTemplate: config.itemTemplate || null,
                change: function(e) {
                    const selectedValues = e.sender.value();
                    options.model[config.fieldName] = [];
                    selectedValues.forEach(value => {
                        const itemObj = config.dataSource.find(i => 
                            String(i.databaseId) === String(value));
                        
                        if (itemObj) {
                            const newItem = { 
                                id: itemObj.id,
                                databaseId: itemObj.databaseId,
                                name: itemObj.name
                            };
                            
                            // Copy additional properties if they exist
                            if (itemObj.firstName) newItem.firstName = itemObj.firstName;
                            if (itemObj.lastName) newItem.lastName = itemObj.lastName;
                            
                            options.model[config.fieldName].push(newItem);
                        }
                    });
                    
                    // Call custom onChange handler if provided
                    if (config.onChange) {
                        config.onChange(e, options);
                    }
                }
            });
            
        return multiSelect;
    }
    
    // Specific editor functions for each taxonomy
    function createOojInfectionEditor(container, options) {
        return createSingleSelectEditor(container, options, {
            fieldName: "oojInfections",
            dataSource: oojInfectionsData,
            placeholder: "Select Infection..."
        });
    }
    
    function createOojActivitiesEditor(container, options) {
        return createMultiSelectEditor(container, options, {
            fieldName: "oojActivities",
            dataSource: oojActivitiesData,
            placeholder: "Select Activities..."
        });
    }
    
    function createMethodsOfTransmittingEditor(container, options) {
        return createMultiSelectEditor(container, options, {
            fieldName: "methodsOfTransmitting",
            dataSource: methodsTransmittingData,
            placeholder: "Select Methods..."
        });
    }
    
    function createAcceptableForPiisEditor(container, options) {
        return createMultiSelectEditor(container, options, {
            fieldName: "acceptableForPiis",
            dataSource: acceptablePiisData,
            placeholder: "Select PIIs..."
        });
    }
    
    function createPointOfContactsEditor(container, options) {

    console.log("Creating PointOfContacts DropDownList editor. Model:", options.model);
    $('<input name="pointOfContacts" required data-required-msg="Point of Contact is required"/>') // Added validation attributes
        .appendTo(container)
        .kendoDropDownList({
            autobind: true, // Bind immediately
            placeholder: "Select Contact...",
            dataTextField: "name", // Display full name (or adjust if needed)
            dataValueField: "databaseId", // Use databaseId as the value
            dataSource: { // Use the global contactsData, mapping to display name
                data: contactsData.map(c => ({ databaseId: c.databaseId, name: `${c.firstName} ${c.lastName}`}))
            },
            // Determine the initial value (handle array vs single object)
            value: (options.model.pointOfContacts && options.model.pointOfContacts.length > 0) ?
                   options.model.pointOfContacts[0].databaseId : null,
            change: function(e) {
                const selectedValue = e.sender.value(); // Get the selected databaseId
                console.log("PointOfContacts DropDownList changed. Selected Value:", selectedValue);
                options.model.pointOfContacts = []; // Clear the existing array

                if (selectedValue) {
                    // Find the full contact object from the global list
                    const contactObj = contactsData.find(c => String(c.databaseId) === String(selectedValue));
                    if (contactObj) {
                         // Store as a single-element array to match potential API expectations
                        options.model.pointOfContacts.push({
                            id: contactObj.id, // Include relay ID if needed
                            databaseId: contactObj.databaseId,
                            firstName: contactObj.firstName,
                            lastName: contactObj.lastName
                        });
                    }
                }
                 options.model.dirty = true; // Mark model as dirty
                 console.log("Updated model.pointOfContacts:", options.model.pointOfContacts);

                 // Manually trigger validation after change if needed
                 var validator = container.closest("tr").kendoValidator().data("kendoValidator");
                 if (validator) {
                    validator.validateInput(e.sender.element);
                 }
            }
        });
}
 
function initOojGrid() {
        // Helper functions for ID extraction (remain the same)
        function extractSingleId(item) {
            if (!item) return null;
            if (Array.isArray(item) && item.length > 0) item = item[0];
            return typeof item === 'object' ? item.databaseId : item;
        }
  
        function extractIds(items) {
            if (!Array.isArray(items) || items.length === 0) return [];
            return items.map(item => typeof item === 'object' ? item.databaseId : item);
        }
  
        // OOJ DETAILS GRID DATASOURCE - REST API implementation (Complexity is necessary for API interaction)
        var oojDataSource = new kendo.data.DataSource({
  // Place this entire 'transport' object within your oojDataSource definition
        // in My_Jurisdiction.html
  // Place this entire 'transport' object within your oojDataSource definition
        // in My_Jurisdiction.html
        transport: {
            // --- CREATE Operation ---
            create: {
                contentType: "application/json", // Tell server we're sending JSON
                url: "https://hivstiooj.cste.org/wp-json/wp/v2/ooj-detail",
                type: "POST",
                xhrFields: { withCredentials: true }, // Send cookies
                beforeSend: function(xhr) {
                    // Adds the nonce security token to the request header
                    if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                        console.log('Create: Setting X-WP-Nonce header:', wpApiSettings.nonce);
                        xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                    } else {
                        console.error('Create: wpApiSettings.nonce is missing!');
                    }
                }
                // Removed 'data' function - handled by parameterMap now
            },
  
            // --- READ Operation ---
            read: {
                url: function() {
                    // Dynamically builds URL with jurisdiction filter and embed flag
                    // Ensure currentJurisdictionId is correctly set before read
                    return "https://hivstiooj.cste.org/wp-json/wp/v2/ooj-detail?jurisdiction=" +
                           currentJurisdictionId + "&_embed&per_page=100";
                },
                type: "GET",
                dataType: "json", // Expect JSON response
                xhrFields: { withCredentials: true }, // Send cookies
                beforeSend: function(xhr) {
                    // Adds the nonce header for authentication
                    if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                        console.log('Read: Setting X-WP-Nonce header:', wpApiSettings.nonce);
                        xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                    } else {
                         console.error('Read: wpApiSettings.nonce is missing!');
                    }
                }
            },
  
            // --- UPDATE Operation ---
            update: {
                contentType: "application/json", // Tell server we're sending JSON
                url: function(options) {
                    // Kendo passes the data item being updated in 'options'
                    // Use the item's actual post ID from the read operation
                    console.log("Update URL using options:", options);
                    return "https://hivstiooj.cste.org/wp-json/wp/v2/ooj-detail/" + options.id;
                },
                type: "POST", // Using POST (as original); could be PUT if server configured
                xhrFields: { withCredentials: true }, // Send cookies
                beforeSend: function(xhr) {
                    // Adds the nonce security token to the request header
                    if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                        console.log('Update: Setting X-WP-Nonce header:', wpApiSettings.nonce);
                        xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                    } else {
                        console.error('Update: wpApiSettings.nonce is missing!');
                    }
                    // If server requires PUT via POST override:
                    // xhr.setRequestHeader('X-HTTP-Method-Override', 'PUT');
                }
                // Removed 'data' function - handled by parameterMap now
            },
  
            // --- DESTROY Operation ---
            destroy: {
                url: function(options) {
                    // Kendo passes the data item being deleted in 'options'
                     console.log("Destroy URL using options:", options);
                     return "https://hivstiooj.cste.org/wp-json/wp/v2/ooj-detail/" + options.id + "?force=true"; // force=true bypasses trash
                },
                type: "DELETE",
                xhrFields: { withCredentials: true }, // Send cookies
                beforeSend: function(xhr) {
                     // Adds the nonce header for authentication
                     if (typeof wpApiSettings !== 'undefined' && wpApiSettings.nonce) {
                        console.log('Destroy: Setting X-WP-Nonce header:', wpApiSettings.nonce);
                        xhr.setRequestHeader('X-WP-Nonce', wpApiSettings.nonce);
                    } else {
                        console.error('Destroy: wpApiSettings.nonce is missing!');
                    }
                }
            },
  
            // --- PARAMETER MAP (Handles data formatting for sending) ---
            parameterMap: function(options, operation) {
                if (operation === "update" || operation === "create") {
  
          // <<< START DIAGNOSTIC CHECK >>>
          if (operation === "update" && (!options.pointOfContacts || options.pointOfContacts.length === 0)) {
               console.error("VALIDATION FAILED (parameterMap check): pointOfContacts is empty, but update transport was called.", options);
               // Optionally, you could try and force validation UI here, though it might be too late.
               // Or, to forcefully STOP the API call *here* (as a temporary measure/test):
               // return "{}"; // Return minimal valid JSON to avoid further errors, but the API call might still happen with empty data.
               // Better: Find a way to truly cancel the sync operation if possible, but that's complex here.
               // For now, just logging the error is the main goal.
          }
          // <<< END DIAGNOSTIC CHECK >>>
  
  
                    // For create/update, manually build the JSON payload
                    // 'options' should contain the model data fields Kendo sends
                    console.log(`parameterMap (${operation}): Preparing data from options:`, options);
  
                    // Ensure helper functions are accessible if needed
                    // function extractIds(items) { ... }
  
                    // Construct the payload object EXACTLY as the API expects it
                    const payloadObject = {
                        title: options.title || "OOJ Detail",
                        status: "publish",
                        acf: { // Use snake_case field names matching ACF export
                            jurisdiction_selection: parseInt(currentJurisdictionId, 10), // Ensure currentJurisdictionId is accessible here
                            last_date_of_exposure: options.lastDateOfExposure || "",
                            point_of_contacts: extractIds(options.pointOfContacts) || [],
                            dispositions_returned: options.dispositionsReturned || "",
                            accept_and_investigate: options.acceptAndInvestigate || "",
                            notes: options.notes || ""
                        },
                         // Use correct hyphenated/underscored taxonomy slugs as keys
                        'acf-ooj-infection': extractIds(options.oojInfections) || [],
                        'acf-ooj-activity': extractIds(options.oojActivities) || [],
                        'iccr_method-of-transmitting': extractIds(options.methodsOfTransmitting) || [],
                        'acceptable-for-pii': extractIds(options.acceptableForPiis) || []
                    };
  
                    // Manually stringify the object to JSON
                    const jsonString = JSON.stringify(payloadObject);
                    console.log(`parameterMap (${operation}): Returning JSON string:`, jsonString);
                    // Return the raw JSON string. Kendo/jQuery should send this directly
                    // as the request body because contentType is 'application/json'
                    return jsonString;
                }
  
                // For 'read', 'destroy', or other operations, return options as is
                // Kendo will handle URL parameters (like sort, filter, page) if needed.
                // If destroy needs specific formatting, handle it here too.
                console.log(`parameterMap (${operation}): Using default handling for options:`, options);
                return options;
            } // --- End PARAMETER MAP ---
  
        }, // End transport
        schema: {
                
              model: {
                    id: "id",
                    fields: { // Include all fields corresponding to original columns
                        id: { editable: false, nullable: true },
                        title: { type: "string", defaultValue: "OOJ Detail" },
                        oojInfections: { defaultValue: [] }, // Maps to taxonomy 'acf-ooj-infection'
                        oojActivities: { defaultValue: [] }, // Maps to taxonomy 'acf-ooj-activity'
                        lastDateOfExposure: { type: "string" }, // Maps to ACF 'last_date_of_exposure'
                        dispositionsReturned: { type: "string" }, // Maps to ACF 'dispositions_returned'
                        acceptAndInvestigate: { type: "string" }, // Maps to ACF 'accept_and_investigate'
                        methodsOfTransmitting: { defaultValue: [] }, // Maps to taxonomy 'iccr_method-of-transmitting'
                        acceptableForPiis: { defaultValue: [] }, // Maps to taxonomy 'acceptable-for-pii'
                        pointOfContacts: {
                            defaultValue: [],
                            validation: { required: true }
                        }, // Maps to ACF 'point_of_contacts'
                        notes: { type: "string" } // Maps to ACF 'notes'
                    }
                },
                parse: function(response) {
                  // Log the raw response received from the transport
                  console.log('Attempting to parse response:', response);
  
                  let dataToProcess = []; // Initialize array to hold items for mapping
  
                  // --- Check if the response is an array or a single object ---
                  if (Array.isArray(response)) {
                      // Response is already an array (likely from READ)
                      dataToProcess = response;
                      console.log('Response is an array, proceeding with map.');
                  } else if (response && typeof response === 'object' && response.id) {
                      // Response is likely a single object (e.g., from CREATE/UPDATE)
                      // Wrap it in an array so .map() works consistently
                      dataToProcess = [response];
                      console.log('Response is a single object, wrapping in array for map.');
                  } else {
                      // Response is not in an expected format (e.g., error, empty, null)
                      console.warn('Response is not an array or valid object, returning empty array. Response:', response);
                      return []; // Return empty array to prevent errors
                  }
                  // --- End Check ---
  
                  // Now map the dataToProcess array (which is guaranteed to be an array here)
                  try {
                      return dataToProcess.map(item => {
                          // Check if the item itself is a valid object before processing
                          if (!item || typeof item !== 'object') {
                              console.warn('Invalid item found in dataToProcess array:', item);
                              return null; // Skip this invalid item
                          }
  
                          console.log("Parsing item:", item); // Log the individual item
  
                          const acfData = item.acf || {};
                          // Create the mapped item structure expected by the Kendo Grid model
                          const mappedItem = {
                              id: item.id,
                              title: item.title?.rendered || item.title || "OOJ Detail", // Handle potential raw title
                              lastDateOfExposure: acfData.last_date_of_exposure || "",
                              dispositionsReturned: acfData.dispositions_returned || "",
                              acceptAndInvestigate: acfData.accept_and_investigate || "",
                              notes: acfData.notes || "",
                              // Initialize relationship arrays
                              pointOfContacts: [],
                              oojInfections: [],
                              oojActivities: [],
                              methodsOfTransmitting: [],
                              acceptableForPiis: []
                          };
  
                          // Process Point of Contacts (User relationship field)
                          const contactIds = acfData.point_of_contacts;
                          if (contactIds && Array.isArray(contactIds)) {
                              const safeContactsData = Array.isArray(contactsData) ? contactsData : []; // Ensure contactsData is usable
                              console.log("Inspecting contactsData:", JSON.stringify(contactsData, null, 2));
                              mappedItem.pointOfContacts = contactIds.map(userId => {
                                  const contactId = typeof userId === 'object' && userId.ID ? userId.ID : userId;
                                  const userObj = safeContactsData.find(contact => contact && String(contact.databaseId) === String(contactId)); // Robust find
                                  if (userObj) {
                                      return { id: userObj.id, databaseId: userObj.databaseId, firstName: userObj.firstName || "", lastName: userObj.lastName || "" };
                                  } else {
                                       console.warn("Contact ID not found in global list:", contactId);
                                       // Represent missing contact if needed, or return null
                                       return { id: null, databaseId: parseInt(contactId, 10) || null, firstName: "Unknown", lastName: "User #" + contactId };
                                  }
                              }).filter(contact => contact !== null && contact.databaseId); // Filter out nulls/invalid
                          }
  
                          // Process Taxonomy Terms
                          const termMappings = {
                             'acf-ooj-infection': { targetArray: 'oojInfections', sourceData: oojInfectionsData },
                             'acf-ooj-activity': { targetArray: 'oojActivities', sourceData: oojActivitiesData },
                             'iccr_method-of-transmitting': { targetArray: 'methodsOfTransmitting', sourceData: methodsTransmittingData },
                             'acceptable-for-pii': { targetArray: 'acceptableForPiis', sourceData: acceptablePiisData }
                          };
  
                          for (const termKey in termMappings) {
                              const mappingInfo = termMappings[termKey];
                              const targetArrayName = mappingInfo.targetArray;
                              // Ensure the global source list is a valid array before using .find
                              const sourceList = Array.isArray(mappingInfo.sourceData) ? mappingInfo.sourceData : [];
  
                              // Check if the term key exists on the item and is an array
                              if (item[termKey] && Array.isArray(item[termKey])) {
                                   console.log(`Processing ${targetArrayName}:`, item[termKey]); // Log IDs received
  
                                   const processedTerms = item[termKey].map(termId => {
                                      // Skip if termId is null or undefined
                                      if (termId === null || termId === undefined) return null;
  
                                      // Find the full term object in the corresponding global list
                                      const foundTerm = sourceList.find(t => t && Number(t.databaseId) === Number(termId)); // Ensure comparison works
  
                                      if (foundTerm) {
                                          // If found, return the object structure needed by the grid/editor
                                          return { id: foundTerm.id, databaseId: foundTerm.databaseId, name: foundTerm.name };
                                      } else {
                                          console.warn("Term ID not found in global list:", termId, "for taxonomy:", termKey);
                                          return null; // Term ID exists in response but not in global list
                                      }
                                  }).filter(term => term !== null); // Remove any nulls from failed lookups
  
                                  // Assign the resulting array of term objects to the mappedItem
                                  mappedItem[targetArrayName] = processedTerms;
                              } else {
                                   // If the key doesn't exist or isn't an array, ensure the target is an empty array
                                   mappedItem[targetArrayName] = [];
                              }
                          } // End term processing loop
  
                          console.log('Final mapped item:', mappedItem);
                          return mappedItem; // Return the processed item for the Kendo model
  
                      }).filter(item => item !== null); // Filter out any null items resulting from errors during mapping
                  } catch (error) {
                      // Catch potential errors during the .map() process itself
                      console.error("Error during map operation in parse:", error, "Data being processed:", dataToProcess);
                      return []; // Return empty array on error
                  }
              }, // End parse function
                 error: function(e) {
                    console.error("DataSource Error:", e);
                    let message = "An error occurred.";
                    if (e.xhr && e.xhr.responseJSON && e.xhr.responseJSON.message) {
                        message = e.xhr.responseJSON.message;
                    } else if (e.errors) {
                        message = Array.isArray(e.errors) ? e.errors.join(", ") : String(e.errors);
                    }
                    showNotification("Error: " + message, 'error');
                    e.preventDefault();
                    var grid = $("#ooj_grid").data("kendoGrid");
                    if(grid) { grid.cancelChanges(); }
                },
                total: function(response) {
                   const data = this.parse(response);
                   return data ? data.length : 0;
                }
            },
           
            change: function(e) {
                console.log('OOJDataSource change event:', e);
                if (e.action === "itemchange") {
                     e.items[0].dirty = true;
                     console.log("Item marked dirty:", e.items[0]);
                }
            }
        });
  
        // GRID INITIALIZATION (Full Original Columns)
        $("#ooj_grid").kendoGrid({
            dataSource: oojDataSource,
           
            scrollable: false,
            sortable: true,
            pageable: false,
            toolbar: ["create"],
            editable: {
                mode: "inline",
                confirmation: "Are you sure you want to cancel the changes?",
                createAt: "top"
            },
            save: function(e) {
          console.log("Grid save event triggered for model:", e.model);
  
          // Get the Kendo Validator instance for the row being edited
          var validator = e.sender.editable.validatable;
  
          // Explicitly validate the inputs in the edited row
          if (validator && !validator.validate()) {
              // If validation fails...
              console.error("Validation failed in save event. Preventing save.");
  
              // Prevent the default save action (which triggers the DataSource sync/transport)
              e.preventDefault();
  
              // No need to return anything, preventDefault() stops the process.
          } else {
              // If validation passes...
              console.log("Validation passed in save event. Allowing save.");
              // The grid will proceed with the default save behavior (triggering transport)
          }
      },
            columns: [ // Restored original column set
                {
                    field: "oojInfections",
                    title: "OOJ Infections",
                    width: 180,
                    template: createTaxonomyTemplate("oojInfections"),
                    editor: createOojInfectionEditor
                },
                {
                    field: "oojActivities",
                    title: "OOJ Activities",
                    width: 180,
                    template: createTaxonomyTemplate("oojActivities"),
                    editor: createOojActivitiesEditor
                },
                { field: "lastDateOfExposure", title: "Last Date of Exposure", width: 180 },
                {
                    field: "dispositionsReturned", // Restored column
                    title: "Dispositions Returned",
                    width: 150,
                },
                {
                    field: "acceptAndInvestigate", // Restored column
                    title: "Accept & Investigate",
                    width: 150,
                },
                {
                    field: "methodsOfTransmitting", // Restored column
                    title: "Methods of Transmitting",
                    width: 180,
                    template: createTaxonomyTemplate("methodsOfTransmitting"),
                    editor: createMethodsOfTransmittingEditor
                },
                {
                    field: "acceptableForPiis", // Restored column
                    title: "Acceptable for PIIs",
                    width: 180,
                    template: createTaxonomyTemplate("acceptableForPiis"),
                    editor: createAcceptableForPiisEditor
                },
                {
                    field: "pointOfContacts",
                    title: "Point of Contacts",
                    width: 180,
                    template: createPointOfContactsTemplate(),
                    editor: createPointOfContactsEditor
                },
                { field: "notes", title: "Notes", width: 180 }, // Restored column
                { command: ["edit", "destroy"], title: "&nbsp;", width: "130px" }
            ]
        });
    }
     </script>
  